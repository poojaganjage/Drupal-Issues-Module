diff --git a/modules/contrib/autologout/autologout.api.php b/modules/contrib/autologout/autologout.api.php
index 698b1e7..d5d275f 100644
--- a/modules/contrib/autologout/autologout.api.php
+++ b/modules/contrib/autologout/autologout.api.php
@@ -1,8 +1,19 @@
 <?php
 
 /**
- * @file
  * Describe hooks provided by the autologout module.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
  */
 
 /**
@@ -18,18 +29,19 @@
  *   Return FALSE (or nothing) if you want to leave the autologout
  *   process alone.
  */
-function hook_autologout_prevent() {
-  // Don't include autologout JS checks on ajax callbacks.
-  $path_args = explode('/', current_path());
-  $blacklist = [
+function Hook_Autologout_prevent()
+{
+    // Don't include autologout JS checks on ajax callbacks.
+    $path_args = explode('/', current_path());
+    $blacklist = [
     'ajax',
     'autologout_ajax_logout',
     'autologout_ajax_set_last',
-  ];
+    ];
 
-  if (in_array($path_args[0], $blacklist)) {
-    return TRUE;
-  }
+    if (in_array($path_args[0], $blacklist)) {
+        return true;
+    }
 }
 
 /**
@@ -41,9 +53,14 @@ function hook_autologout_prevent() {
  *   to the server to keep the login alive.
  *   Return FALSE (or nothing) to just use the standard behaviour.
  */
-function hook_autologout_refresh_only() {
-  // Check to see if an open admin page will keep login alive.
-  if (\Drupal::service('router.admin_context')->isAdminRoute(routeMatch()->getRouteObject()) && !\Drupal::config('autologout.settings')->get('enforce_admin')) {
-    return TRUE;
-  }
+function Hook_Autologout_Refresh_only()
+{
+    // Check to see if an open admin page will keep login alive.
+    if (\Drupal::service('router.admin_context')->isAdminRoute(
+        routeMatch()->
+        getRouteObject()
+    ) && !\Drupal::config('autologout.settings')->get('enforce_admin')
+    ) {
+        return true;
+    }
 }
diff --git a/modules/contrib/autologout/autologout.services.yml b/modules/contrib/autologout/autologout.services.yml
index f821b9f..ccafdce 100644
--- a/modules/contrib/autologout/autologout.services.yml
+++ b/modules/contrib/autologout/autologout.services.yml
@@ -3,10 +3,16 @@ services:
     class: Drupal\autologout\EventSubscriber\AutologoutSubscriber
     tags:
       - {name: event_subscriber}
-    arguments: ['@autologout.manager', '@current_user', '@config.factory','@theme.manager','@datetime.time']
+    arguments: ['@autologout.manager', '@current_user', '@config.factory','@theme.manager','@datetime.time','@request_stack']
 
   autologout.manager:
     class: Drupal\autologout\AutologoutManager
     tags:
       - {name: autologout_manager}
-    arguments: ['@module_handler', '@config.factory', '@messenger', '@current_user', '@logger.factory', '@session_manager', '@user.data', '@datetime.time']
+    arguments: ['@module_handler', '@config.factory', '@messenger', '@current_user', '@logger.factory', '@session_manager', '@user.data', '@datetime.time','@entity_type.manager']
+
+  autologout_controller:
+    class: Drupal\autologout\Controller\AutologoutController
+    tags:
+      - {name: controller}
+    arguments: ['@url_generator.non_bubbling']
\ No newline at end of file
diff --git a/modules/contrib/autologout/src/AutologoutManager.php b/modules/contrib/autologout/src/AutologoutManager.php
index 1495177..ae48423 100644
--- a/modules/contrib/autologout/src/AutologoutManager.php
+++ b/modules/contrib/autologout/src/AutologoutManager.php
@@ -1,5 +1,21 @@
 <?php
 
+/**
+ * Provides autologout manager Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\autologout;
 
 use Drupal\Component\Datetime\TimeInterface;
@@ -14,330 +30,389 @@
 use Drupal\user\UserData;
 use Drupal\Component\Utility\Xss;
 use Drupal\Core\StringTranslation\StringTranslationTrait;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
 
 /**
- * Defines an AutologoutManager service.
+ * Provides autologout manager Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-class AutologoutManager implements AutologoutManagerInterface {
-
-  use StringTranslationTrait;
-
-  /**
-   * The module manager service.
-   *
-   * @var \Drupal\Core\Extension\ModuleHandlerInterface
-   */
-  protected $moduleHandler;
-
-  /**
-   * The config object for 'autologout.settings'.
-   *
-   * @var \Drupal\Core\Config\Config
-   */
-  protected $autoLogoutSettings;
-
-  /**
-   * The config factory service.
-   *
-   * @var \Drupal\Core\Config\ConfigFactoryInterface
-   */
-  protected $configFactory;
-
-  /**
-   * The Messenger service.
-   *
-   * @var \Drupal\Core\Messenger\MessengerInterface
-   */
-  protected $messenger;
-  /**
-   * The current user.
-   *
-   * @var \Drupal\Core\Session\AccountInterface
-   */
-  protected $currentUser;
-
-  /**
-   * Logger service.
-   *
-   * @var \Drupal\Core\Logger\LoggerChannelInterface
-   */
-  protected $logger;
-
-  /**
-   * The session.
-   *
-   * @var \Drupal\Core\Session\SessionManager
-   */
-  protected $session;
-
-  /**
-   * Data of the user.
-   *
-   * @var \Drupal\user\UserDataInterface
-   */
-  protected $userData;
-
-  /**
-   * The Time Service.
-   *
-   * @var \Drupal\Component\Datetime\TimeInterface
-   */
-  protected $time;
-
-  /**
-   * Constructs an AutologoutManager object.
-   *
-   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
-   *   The module handler.
-   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
-   *   The config factory.
-   * @param \Drupal\Core\Messenger\MessengerInterface $messenger
-   *   The messenger service.
-   * @param \Drupal\Core\Session\AccountInterface $current_user
-   *   Data of the user.
-   * @param \Drupal\Core\Logger\LoggerChannelFactoryInterface $logger
-   *   Logger service.
-   * @param \Drupal\Core\Session\SessionManager $sessionManager
-   *   The session.
-   * @param \Drupal\user\UserData $userData
-   *   Data of the user.
-   * @param \Drupal\Component\Datetime\TimeInterface $time
-   *   The time service.
-   */
-  public function __construct(
-    ModuleHandlerInterface $module_handler,
-    ConfigFactoryInterface $config_factory,
-    MessengerInterface $messenger,
-    AccountInterface $current_user,
-    LoggerChannelFactoryInterface $logger,
-    SessionManager $sessionManager,
-    UserData $userData,
-    TimeInterface $time
-  ) {
-    $this->moduleHandler = $module_handler;
-    $this->autoLogoutSettings = $config_factory->get('autologout.settings');
-    $this->configFactory = $config_factory;
-    $this->messenger = $messenger;
-    $this->currentUser = $current_user;
-    $this->logger = $logger->get('autologout');
-    $this->session = $sessionManager;
-    $this->userData = $userData;
-    $this->time = $time;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function preventJs() {
-    foreach ($this->moduleHandler->invokeAll('autologout_prevent') as $prevent) {
-      if (!empty($prevent)) {
-        return TRUE;
-      }
+class AutologoutManager implements AutologoutManagerInterface
+{
+
+    use StringTranslationTrait;
+
+    /**
+     * The module manager service.
+     *
+     * @var \Drupal\Core\Extension\ModuleHandlerInterface
+     */
+    protected $moduleHandler;
+
+    /**
+     * The config object for 'autologout.settings'.
+     *
+     * @var \Drupal\Core\Config\Config
+     */
+    protected $autoLogoutSettings;
+
+    /**
+     * The config factory service.
+     *
+     * @var \Drupal\Core\Config\ConfigFactoryInterface
+     */
+    protected $configFactory;
+
+    /**
+     * The Messenger service.
+     *
+     * @var \Drupal\Core\Messenger\MessengerInterface
+     */
+    protected $messenger;
+    /**
+     * The current user.
+     *
+     * @var \Drupal\Core\Session\AccountInterface
+     */
+    protected $currentUser;
+
+    /**
+     * Logger service.
+     *
+     * @var \Drupal\Core\Logger\LoggerChannelInterface
+     */
+    protected $logger;
+
+    /**
+     * The session.
+     *
+     * @var \Drupal\Core\Session\SessionManager
+     */
+    protected $session;
+
+    /**
+     * Data of the user.
+     *
+     * @var \Drupal\user\UserDataInterface
+     */
+    protected $userData;
+
+    /**
+     * The Time Service.
+     *
+     * @var \Drupal\Component\Datetime\TimeInterface
+     */
+    protected $time;
+
+    /**
+     * The Entity Type Manager.
+     *
+     * @var Drupal\Core\Entity\EntityTypeManagerInterface
+     */
+    protected $entityTypeManager;
+
+    /**
+     * Constructs an AutologoutManager object.
+     *
+     * @param $module_handler    The module handler
+     * @param $config_factory    The config factory.
+     * @param $messenger         The messenger service.
+     * @param $current_user      Data of the user.
+     * @param $logger            Logger service.
+     * @param $sessionManager    The session.
+     * @param $userData          Data of the user.
+     * @param $time              The time service.
+     * @param $entityTypeManager The Entity Type Manager.
+     */
+    public function __construct(
+        ModuleHandlerInterface $module_handler,
+        ConfigFactoryInterface $config_factory,
+        MessengerInterface $messenger,
+        AccountInterface $current_user,
+        LoggerChannelFactoryInterface $logger,
+        SessionManager $sessionManager,
+        UserData $userData,
+        TimeInterface $time,
+        EntityTypeManagerInterface $entityTypeManager
+    ) {
+        $this->moduleHandler = $module_handler;
+        $this->autoLogoutSettings = $config_factory->get('autologout.settings');
+        $this->configFactory = $config_factory;
+        $this->messenger = $messenger;
+        $this->currentUser = $current_user;
+        $this->logger = $logger->get('autologout');
+        $this->session = $sessionManager;
+        $this->userData = $userData;
+        $this->time = $time;
+        $this->entityTypeManager = $entityTypeManager;
     }
 
-    return FALSE;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function refreshOnly() {
-    foreach ($this->moduleHandler->invokeAll('autologout_refresh_only') as $module_refresh_only) {
-      if (!empty($module_refresh_only)) {
-        return TRUE;
-      }
-    }
+    /**
+     * {@inheritdoc}
+     *
+     * @return bool
+     */
+    public function preventJs()
+    {
+        foreach ($this->moduleHandler->invokeAll('autologout_prevent') as $prevent) {
+            if (!empty($prevent)) {
+                return true;
+            }
+        }
 
-    return FALSE;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function inactivityMessage() {
-    $message = Xss::filter($this->autoLogoutSettings->get('inactivity_message'));
-    $type = $this->autoLogoutSettings->get('inactivity_message_type');
-    if (!empty($message)) {
-      $this->messenger->addMessage($this->t($message), $type);
+        return false;
     }
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function logout() {
-    $user = $this->currentUser;
-    if ($this->autoLogoutSettings->get('use_watchdog')) {
-      $this->logger->info(
-        'Session automatically closed for %name by autologout.',
-        ['%name' => $user->getAccountName()]
-      );
+
+    /**
+     * {@inheritdoc}
+     *
+     * @return bool
+     */
+    public function refreshOnly()
+    {
+        foreach ($this->moduleHandler->invokeAll('autologout_refresh_only') 
+        as $module_refresh_only) {
+            if (!empty($module_refresh_only)) {
+                return true;
+            }
+        }
+
+        return false;
     }
 
-    // Destroy the current session.
-    $this->moduleHandler->invokeAll('user_logout', [$user]);
-    $this->session->destroy();
-    $user->setAccount(new AnonymousUserSession());
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getRoleTimeout() {
-    $roles = user_roles(TRUE);
-    $role_timeout = [];
-
-    // Go through roles, get timeouts for each and return as array.
-    foreach ($roles as $name => $role) {
-      $role_settings = $this->configFactory->get('autologout.role.' . $name);
-      if ($role_settings->get('enabled')) {
-        $timeout_role = $role_settings->get('timeout');
-        $role_timeout[$name] = $timeout_role;
-      }
+    /**
+     * {@inheritdoc}
+     *
+     * @return object
+     */
+    public function inactivityMessage()
+    {
+        $message = Xss::filter($this->autoLogoutSettings->get('inactivity_message'));
+        $type = $this->autoLogoutSettings->get('inactivity_message_type');
+        if (!empty($message)) {
+            $this->messenger->addMessage($this->t($message), $type);
+        }
     }
 
-    return $role_timeout;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getRoleUrl() {
-    $roles = user_roles(TRUE);
-    $role_url = [];
-
-    // Go through roles, get timeouts for each and return as array.
-    foreach ($roles as $name => $role) {
-      $role_settings = $this->configFactory->get('autologout.role.' . $name);
-      if ($role_settings->get('enabled')) {
-        $url_role = $role_settings->get('url');
-        $role_url[$name] = $url_role;
-      }
+    /**
+     * {@inheritdoc}
+     *
+     * @return object
+     */
+    public function logout()
+    {
+        $user = $this->currentUser;
+        if ($this->autoLogoutSettings->get('use_watchdog')) {
+            $this->logger->info(
+                'Session automatically closed for %name by autologout.',
+                ['%name' => $user->getAccountName()]
+            );
+        }
+
+        // Destroy the current session.
+        $this->moduleHandler->invokeAll('user_logout', [$user]);
+        $this->session->destroy();
+        $user->setAccount(new AnonymousUserSession());
     }
-    return $role_url;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getRemainingTime() {
-    $timeout = $this->getUserTimeout();
-    $time_passed = isset($_SESSION['autologout_last'])
-      ? $this->time->getRequestTime() - $_SESSION['autologout_last']
-      : 0;
-
-    return $timeout - $time_passed;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function createTimer() {
-    return $this->getRemainingTime();
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getUserTimeout($uid = NULL) {
-    if (is_null($uid)) {
-      // If $uid is not provided, use the logged in user.
-      $user = $this->currentUser;
+
+    /**
+     * {@inheritdoc}
+     *
+     * @return array
+     */
+    public function getRoleTimeout()
+    {
+        $roles = user_roles(true);
+        $role_timeout = [];
+
+        // Go through roles, get timeouts for each and return as array.
+        foreach ($roles as $name => $role) {
+            $role_settings = $this->configFactory->get('autologout.role.' . $name);
+            if ($role_settings->get('enabled')) {
+                $timeout_role = $role_settings->get('timeout');
+                $role_timeout[$name] = $timeout_role;
+            }
+        }
+
+        return $role_timeout;
     }
-    else {
-      $user = User::load($uid);
+
+    /**
+     * {@inheritdoc}
+     *
+     * @return array
+     */
+    public function getRoleUrl()
+    {
+        $roles = user_roles(true);
+        $role_url = [];
+
+        // Go through roles, get timeouts for each and return as array.
+        foreach ($roles as $name => $role) {
+            $role_settings = $this->configFactory->get('autologout.role.' . $name);
+            if ($role_settings->get('enabled')) {
+                $url_role = $role_settings->get('url');
+                $role_url[$name] = $url_role;
+            }
+        }
+        return $role_url;
     }
 
-    if ($user->id() == 0) {
-      // Anonymous doesn't get logged out.
-      return 0;
+    /**
+     * {@inheritdoc}
+     *
+     * @return array
+     */
+    public function getRemainingTime()
+    {
+        $timeout = $this->getUserTimeout();
+        $time_passed = isset($_SESSION['autologout_last'])
+        ? $this->time->getRequestTime() - $_SESSION['autologout_last']
+        : 0;
+
+        return $timeout - $time_passed;
     }
-    $user_timeout = $this->userData->get('autologout', $user->id(), 'timeout');
 
-    if (is_numeric($user_timeout)) {
-      // User timeout takes precedence.
-      return $user_timeout;
+    /**
+     * {@inheritdoc}
+     *
+     * @return object
+     */
+    public function createTimer()
+    {
+        return $this->getRemainingTime();
     }
 
-    // Get role timeouts for user.
-    if ($this->autoLogoutSettings->get('role_logout')) {
-      $user_roles = $user->getRoles();
-      $output = [];
-      $timeouts = $this->getRoleTimeout();
-      foreach ($user_roles as $rid => $role) {
-        if (isset($timeouts[$role])) {
-          $output[$rid] = $timeouts[$role];
+    /**
+     * {@inheritdoc}
+     *
+     * @param $uid This is the unique id.
+     *
+     * @return int
+     */
+    public function getUserTimeout($uid = null)
+    {
+        if (is_null($uid)) {
+            // If $uid is not provided, use the logged in user.
+            $user = $this->currentUser;
+        } else {
+            $user = $this->entityTypeManager->getStorage('user')->load($uid);
         }
-      }
 
-      // Assign the lowest/highest timeout value to be session timeout value.
-      if (!empty($output)) {
-        // If one of the user's roles has a unique timeout, use this.
-        if ($this->autoLogoutSettings->get('role_logout_max')) {
-          return max($output);
+        if ($user->id() == 0) {
+            // Anonymous doesn't get logged out.
+            return 0;
         }
-        else {
-          return min($output);
+        $user_timeout = $this->userData->get('autologout', $user->id(), 'timeout');
+
+        if (is_numeric($user_timeout)) {
+            // User timeout takes precedence.
+            return $user_timeout;
         }
-      }
-    }
 
-    // If no user or role override exists, return the default timeout.
-    return $this->autoLogoutSettings->get('timeout');
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getUserRedirectUrl($uid = NULL) {
-    if (is_null($uid)) {
-      // If $uid is not provided, use the logged in user.
-      $user = \Drupal::currentUser();
-    }
-    else {
-      $user = User::load($uid);
-    }
+        // Get role timeouts for user.
+        if ($this->autoLogoutSettings->get('role_logout')) {
+            $user_roles = $user->getRoles();
+            $output = [];
+            $timeouts = $this->getRoleTimeout();
+            foreach ($user_roles as $rid => $role) {
+                if (isset($timeouts[$role])) {
+                    $output[$rid] = $timeouts[$role];
+                }
+            }
+
+            // Assign the lowest/highest timeout value to be session timeout value.
+            if (!empty($output)) {
+                // If one of the user's roles has a unique timeout, use this.
+                if ($this->autoLogoutSettings->get('role_logout_max')) {
+                    return max($output);
+                } else {
+                    return min($output);
+                }
+            }
+        }
 
-    if ($user->id() == 0) {
-      // Anonymous doesn't get logged out.
-      return;
+        // If no user or role override exists, return the default timeout.
+        return $this->autoLogoutSettings->get('timeout');
     }
 
-    // Get role timeouts for user.
-    if ($this->autoLogoutSettings->get('role_logout')) {
-      $user_roles = $user->getRoles();
-      $output = [];
-      $urls = $this->getRoleUrl();
-      foreach ($user_roles as $rid => $role) {
-        if (isset($urls[$role])) {
-          $output[$rid] = $urls[$role];
+    /**
+     * {@inheritdoc}
+     *
+     * @param $uid This is the unique id.
+     *
+     * @return int
+     */
+    public function getUserRedirectUrl($uid = null)
+    {
+        if (is_null($uid)) {
+            // If $uid is not provided, use the logged in user.
+            $user = $this->entityTypeManager->getStorage('user')
+                ->load($this->currentUser->id());
+        } else {
+            // $user = User::load($uid);
+            $user = $this->entityTypeManager->getStorage('user')->load($uid);
         }
-      }
 
-      // Assign the first matching Role.
-      if (!empty($output) && !empty(reset($output))) {
-        // If one of the user's roles has a unique URL, use this.
-        return reset($output);
-      }
-    }
+        if ($user->id() == 0) {
+            // Anonymous doesn't get logged out.
+            return;
+        }
 
-    // If no user or role override exists, return the default timeout.
-    return $this->autoLogoutSettings->get('redirect_url');
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function logoutRole($user) {
-    if ($this->autoLogoutSettings->get('role_logout')) {
-      foreach ($user->roles as $name => $role) {
-        if ($this->configFactory->get('autologout.role.' . $name . '.enabled')) {
-          return TRUE;
+        // Get role timeouts for user.
+        if ($this->autoLogoutSettings->get('role_logout')) {
+            $user_roles = $user->getRoles();
+            $output = [];
+            $urls = $this->getRoleUrl();
+            foreach ($user_roles as $rid => $role) {
+                if (isset($urls[$role])) {
+                    $output[$rid] = $urls[$role];
+                }
+            }
+
+            // Assign the first matching Role.
+            if (!empty($output) && !empty(reset($output))) {
+                // If one of the user's roles has a unique URL, use this.
+                return reset($output);
+            }
         }
-      }
+
+        // If no user or role override exists, return the default timeout.
+        return $this->autoLogoutSettings->get('redirect_url');
     }
 
-    return FALSE;
-  }
+    /**
+     * {@inheritdoc}
+     *
+     * @param $user This is the user logout role.
+     *
+     * @return bool
+     */
+    public function logoutRole(User $user)
+    {
+        if ($this->autoLogoutSettings->get('role_logout')) {
+            foreach ($user->roles as $name => $role) {
+                if ($this->configFactory->get(
+                    'autologout.role.' . $name . 
+                    '.enabled'
+                )
+                ) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
 
 }
diff --git a/modules/contrib/autologout/src/AutologoutManagerInterface.php b/modules/contrib/autologout/src/AutologoutManagerInterface.php
index 2ba962c..ffc60c9 100644
--- a/modules/contrib/autologout/src/AutologoutManagerInterface.php
+++ b/modules/contrib/autologout/src/AutologoutManagerInterface.php
@@ -1,110 +1,140 @@
 <?php
 
+/**
+ * Provides autologout manager interface Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\autologout;
 
 use Drupal\user\Entity\User;
 
 /**
- * Interface for AutologoutManager.
+ * Provides autologout manager interface Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-interface AutologoutManagerInterface {
-
-  /**
-   * Get the timer HTML markup.
-   *
-   * @return string
-   *   HTML to insert a countdown timer.
-   */
-  public function createTimer();
-
-  /**
-   * Get the time remaining before logout.
-   *
-   * @return int
-   *   Number of seconds remaining.
-   */
-  public function getRemainingTime();
-
-  /**
-   * Go through every role to get timeout value, default is the global timeout.
-   *
-   * @return int
-   *   Number of seconds timeout set for the user role.
-   */
-  public function getRoleTimeout();
-
-  /**
-   * Iterate roles to get the per-role logout URL, default is the global URL.
-   *
-   * @return array
-   *   List of roles with logout URL.
-   */
-  public function getRoleUrl();
-
-  /**
-   * Get a user's timeout in seconds.
-   *
-   * @param int $uid
-   *   (Optional) Provide a user's uid to get the timeout for.
-   *   Default is the logged in user.
-   *
-   * @return int
-   *   The number of seconds the user can be idle for before being logged out.
-   *   A value of 0 means no timeout.
-   */
-  public function getUserTimeout($uid = NULL);
-
-  /**
-   * Get a user's logout URL.
-   *
-   * @param null|int $uid
-   *   User id or NULL to use current logged in user.
-   *
-   * @return null|string
-   *   User's logout URL or NULL for anonymous user.
-   */
-  public function getUserRedirectUrl($uid = NULL);
-
-  /**
-   * Perform Logout.
-   *
-   * Helper to perform the actual logout. Destroys the session of the logged
-   * in user.
-   */
-  public function logout();
-
-  /**
-   * Helper to determine if a given user should be autologged out.
-   *
-   * @param \Drupal\user\Entity\User $user
-   *   User entity.
-   *
-   * @return bool
-   *   TRUE if the user should be autologged out, otherwise FALSE.
-   */
-  public function logoutRole(User $user);
-
-  /**
-   * Display the inactivity message if required when the user is logged out.
-   */
-  public function inactivityMessage();
-
-  /**
-   * Determine if autologout should be prevented.
-   *
-   * @return bool
-   *   TRUE if there is a reason not to autologout
-   *   the current user on the current page.
-   */
-  public function preventJs();
-
-  /**
-   * Determine if connection should be refreshed.
-   *
-   * @return bool
-   *   TRUE if something about the current context should keep the connection
-   *   open. FALSE and the standard countdown to autologout applies.
-   */
-  public function refreshOnly();
+interface AutologoutManagerInterface
+{
+
+    /**
+     * Get the timer HTML markup.
+     *
+     * @return string
+     *   HTML to insert a countdown timer.
+     */
+    public function createTimer();
+
+    /**
+     * Get the time remaining before logout.
+     *
+     * @return int
+     *   Number of seconds remaining.
+     */
+    public function getRemainingTime();
+
+    /**
+     * Go through every role to get timeout value, default is the global timeout.
+     *
+     * @return int
+     *   Number of seconds timeout set for the user role.
+     */
+    public function getRoleTimeout();
+
+    /**
+     * Iterate roles to get the per-role logout URL, default is the global URL.
+     *
+     * @return array
+     *   List of roles with logout URL.
+     */
+    public function getRoleUrl();
+
+    /**
+     * Get a user's timeout in seconds.
+     *
+     * @param int $uid (Optional) Provide a user's uid to get the timeout for.
+     *                 Default is the logged in user.
+     *
+     * @return int
+     *   The number of seconds the user can be idle for before being logged out.
+     *   A value of 0 means no timeout.
+     */
+    public function getUserTimeout($uid = null);
+
+    /**
+     * Get a user's logout URL.
+     *
+     * @param null|int $uid User id or NULL to use current logged in user.
+     *
+     * @return null|string
+     *   User's logout URL or NULL for anonymous user.
+     */
+    public function getUserRedirectUrl($uid = null);
+
+    /**
+     * Perform Logout.
+     *
+     * Helper to perform the actual logout. Destroys the session of the logged
+     * in user.
+     *
+     * @return bool
+     */
+    public function logout();
+
+    /**
+     * Helper to determine if a given user should be autologged out.
+     *
+     * @param \Drupal\user\Entity\User $user User entity.
+     *
+     * @return bool
+     *   TRUE if the user should be autologged out, otherwise FALSE.
+     */
+    public function logoutRole(User $user);
+
+    /**
+     * Display the inactivity message if required when the user is logged out.
+     *
+     * @return bool
+     */
+    public function inactivityMessage();
+
+    /**
+     * Determine if autologout should be prevented.
+     *
+     * @return bool
+     *   TRUE if there is a reason not to autologout
+     *   the current user on the current page.
+     */
+    public function preventJs();
+
+    /**
+     * Determine if connection should be refreshed.
+     *
+     * @return bool
+     *   TRUE if something about the current context should keep the connection
+     *   open. FALSE and the standard countdown to autologout applies.
+     */
+    public function refreshOnly();
 
 }
diff --git a/modules/contrib/autologout/src/Controller/AutologoutController.php b/modules/contrib/autologout/src/Controller/AutologoutController.php
index a986a82..6a3057d 100644
--- a/modules/contrib/autologout/src/Controller/AutologoutController.php
+++ b/modules/contrib/autologout/src/Controller/AutologoutController.php
@@ -1,5 +1,21 @@
 <?php
 
+/**
+ * Provides autologout Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\autologout\Controller;
 
 use Drupal\autologout\AutologoutManagerInterface;
@@ -9,113 +25,154 @@
 use Drupal\Core\Ajax\ReplaceCommand;
 use Drupal\Core\Ajax\SettingsCommand;
 use Drupal\Core\Controller\ControllerBase;
-use Drupal\Core\Url;
+//use Drupal\Core\Url;
 use Symfony\Component\HttpFoundation\RedirectResponse;
+use Drupal\Core\Routing\UrlGenerator;
 
 /**
  * Returns responses for autologout module routes.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-class AutologoutController extends ControllerBase {
-
-  /**
-   * The autologout manager service.
-   *
-   * @var \Drupal\autologout\AutologoutManagerInterface
-   */
-  protected $autoLogoutManager;
-
-
-  /**
-   * The Time Service.
-   *
-   * @var \Drupal\Component\Datetime\TimeInterface
-   */
-  protected $time;
-
-  /**
-   * Constructs an AutologoutSubscriber object.
-   *
-   * @param \Drupal\autologout\AutologoutManagerInterface $autologout
-   *   The autologout manager service.
-   * @param \Drupal\Component\Datetime\TimeInterface $time
-   *   The time service.
-   */
-  public function __construct(
-    AutologoutManagerInterface $autologout,
-    TimeInterface $time
-  ) {
-    $this->autoLogoutManager = $autologout;
-    $this->time = $time;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public static function create(ContainerInterface $container) {
-    return new static(
-      $container->get('autologout.manager'),
-      $container->get('datetime.time')
-    );
-  }
-
-  /**
-   * Alternative logout.
-   */
-  public function altLogout() {
-    $this->autoLogoutManager->logout();
-    $redirect_url = $this->config('autologout.settings')->get('redirect_url');
-    $url = Url::fromUserInput(
-      $redirect_url,
-      [
-        'absolute' => TRUE,
-        'query' => [
-          'autologout_timeout' => 1,
-        ],
-      ]
-    );
-
-    return new RedirectResponse($url->toString());
-  }
-
-  /**
-   * AJAX logout.
-   */
-  public function ajaxLogout() {
-    $this->autoLogoutManager->logout();
-    $response = new AjaxResponse();
-    $response->setStatusCode(200);
-
-    return $response;
-  }
-
-  /**
-   * Ajax callback to reset the last access session variable.
-   */
-  public function ajaxSetLast() {
-    $_SESSION['autologout_last'] = $this->time->getRequestTime();
-
-    // Reset the timer.
-    $response = new AjaxResponse();
-    $markup = $this->autoLogoutManager->createTimer();
-    $response->addCommand(new ReplaceCommand('#timer', $markup));
-
-    return $response;
-  }
-
-  /**
-   * AJAX callback that returns the time remaining for this user is logged out.
-   */
-  public function ajaxGetRemainingTime() {
-    $time_remaining_ms = $this->autoLogoutManager->getRemainingTime() * 1000;
-
-    // Reset the timer.
-    $response = new AjaxResponse();
-    $markup = $this->autoLogoutManager->createTimer();
-
-    $response->addCommand(new ReplaceCommand('#timer', $markup));
-    $response->addCommand(new SettingsCommand(['time' => $time_remaining_ms]));
-
-    return $response;
-  }
+class AutologoutController extends ControllerBase
+{
+
+    /**
+     * The autologout manager service.
+     *
+     * @var \Drupal\autologout\AutologoutManagerInterface
+     */
+    protected $autoLogoutManager;
+
+
+    /**
+     * The Time Service.
+     *
+     * @var \Drupal\Component\Datetime\TimeInterface
+     */
+    protected $time;
+
+    /**
+     * The Url Generate Service.
+     *
+     * @var \Drupal\Core\Routing\UrlGenerator
+     */
+    protected $urlGenerator;
+
+    /**
+     * Constructs an AutologoutSubscriber object.
+     *
+     * The autologout manager service.
+     *
+     * @param $autologout   The autologout service.
+     * @param $time         The time service.
+     * @param $urlGenerator The Url Generate Service
+     */
+    public function __construct(
+        AutologoutManagerInterface $autologout,
+        TimeInterface $time, UrlGenerator $urlGenerator
+    ) {
+        $this->autoLogoutManager = $autologout;
+        $this->time = $time;
+        $this->urlGenerator = $urlGenerator;
+    }
+
+    /**
+     * Create Method.
+     *
+     * @param $container The container variable.
+     *
+     * @return object
+     */
+    public static function create(ContainerInterface $container)
+    {
+        return new static(
+            $container->get('autologout.manager'),
+            $container->get('datetime.time'),
+            $container->get('url_generator.non_bubbling')
+        );
+    }
+
+    /**
+     * Alternative logout.
+     *
+     * @return string
+     */
+    public function altLogout()
+    {
+        $this->autoLogoutManager->logout();
+        $redirect_url = $this->config('autologout.settings')->get('redirect_url');
+        $url = $this->urlGenerator->generateFromRoute(
+            $redirect_url,
+            [
+            'absolute' => true,
+            'query' => [
+            'autologout_timeout' => 1,
+            ],
+            ]
+        );
+
+        return new RedirectResponse($url->toString());
+    }
+
+    /**
+     * AJAX logout.
+     *
+     * @return Time
+     */
+    public function ajaxLogout()
+    {
+        $this->autoLogoutManager->logout();
+        $response = new AjaxResponse();
+        $response->setStatusCode(200);
+
+        return $response;
+    }
+
+    /**
+     * Ajax callback to reset the last access session variable.
+     *
+     * @return Time
+     */
+    public function ajaxSetLast()
+    {
+        $_SESSION['autologout_last'] = $this->time->getRequestTime();
+
+        // Reset the timer.
+        $response = new AjaxResponse();
+        $markup = $this->autoLogoutManager->createTimer();
+        $response->addCommand(new ReplaceCommand('#timer', $markup));
+
+        return $response;
+    }
+
+    /**
+     * AJAX callback that returns the time remaining for this user is logged out.
+     *
+     * @return Time
+     */
+    public function ajaxGetRemainingTime()
+    {
+        $time_remaining_ms = $this->autoLogoutManager->getRemainingTime() * 1000;
+
+        // Reset the timer.
+        $response = new AjaxResponse();
+        $markup = $this->autoLogoutManager->createTimer();
+
+        $response->addCommand(new ReplaceCommand('#timer', $markup));
+        $response->addCommand(new SettingsCommand(['time' => $time_remaining_ms]));
+
+        return $response;
+    }
 
 }
diff --git a/modules/contrib/autologout/src/EventSubscriber/AutologoutSubscriber.php b/modules/contrib/autologout/src/EventSubscriber/AutologoutSubscriber.php
index 8cbc038..4c8f519 100644
--- a/modules/contrib/autologout/src/EventSubscriber/AutologoutSubscriber.php
+++ b/modules/contrib/autologout/src/EventSubscriber/AutologoutSubscriber.php
@@ -1,5 +1,21 @@
 <?php
 
+/**
+ * Provides autologout subscriber Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\autologout\EventSubscriber;
 
 use Drupal\autologout\AutologoutManagerInterface;
@@ -10,129 +26,166 @@
 use Symfony\Component\HttpKernel\KernelEvents;
 use Symfony\Component\HttpKernel\Event\GetResponseEvent;
 use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\HttpFoundation\RequestStack;
 
 /**
- * Defines autologout Subscriber.
+ * Provides autologout subscriber Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-class AutologoutSubscriber implements EventSubscriberInterface {
-
-  /**
-   * The autologout manager service.
-   *
-   * @var \Drupal\autologout\AutologoutManagerInterface
-   */
-  protected $autoLogoutManager;
-
-  /**
-   * The user account service.
-   *
-   * @var \Drupal\Core\Session\AccountInterface
-   */
-  protected $currentUser;
-
-  /**
-   * The Config service.
-   *
-   * @var \Drupal\Core\Config\ConfigFactory
-   */
-  protected $config;
-
-  /**
-   * The theme manager service.
-   *
-   * @var \Drupal\Core\Theme\ThemeManager
-   */
-  protected $theme;
-
-  /**
-   * The Time Service.
-   *
-   * @var \Drupal\Component\Datetime\TimeInterface
-   */
-  protected $time;
-
-  /**
-   * Constructs an AutologoutSubscriber object.
-   *
-   * @param \Drupal\autologout\AutologoutManagerInterface $autologout
-   *   The autologout manager service.
-   * @param \Drupal\Core\Session\AccountInterface $account
-   *   The user account service.
-   * @param \Drupal\Core\Config\ConfigFactory $config
-   *   The Config service.
-   * @param \Drupal\Core\Theme\ThemeManager $theme
-   *   The theme manager service.
-   * @param \Drupal\Component\Datetime\TimeInterface $time
-   *   The time service.
-   */
-  public function __construct(AutologoutManagerInterface $autologout, AccountInterface $account, ConfigFactory $config, ThemeManager $theme, TimeInterface $time) {
-    $this->autoLogoutManager = $autologout;
-    $this->currentUser = $account;
-    $this->config = $config;
-    $this->theme = $theme;
-    $this->time = $time;
-  }
-
-  /**
-   * Check for autologout JS.
-   *
-   * @param \Symfony\Component\HttpKernel\Event\GetResponseEvent $event
-   *   The request event.
-   */
-  public function onRequest(GetResponseEvent $event) {
-    $autologout_manager = $this->autoLogoutManager;
-
-    $uid = $this->currentUser->id();
-
-    if ($uid == 0) {
-      if (!empty($_GET['autologout_timeout']) && $_GET['autologout_timeout'] == 1 && empty($_POST)) {
-        $autologout_manager->inactivityMessage();
-      }
-      return;
+class AutologoutSubscriber implements EventSubscriberInterface
+{
+
+    /**
+     * The autologout manager service.
+     *
+     * @var \Drupal\autologout\AutologoutManagerInterface
+     */
+    protected $autoLogoutManager;
+
+    /**
+     * The user account service.
+     *
+     * @var \Drupal\Core\Session\AccountInterface
+     */
+    protected $currentUser;
+
+    /**
+     * The Config service.
+     *
+     * @var \Drupal\Core\Config\ConfigFactory
+     */
+    protected $config;
+
+    /**
+     * The theme manager service.
+     *
+     * @var \Drupal\Core\Theme\ThemeManager
+     */
+    protected $theme;
+
+    /**
+     * The Time Service.
+     *
+     * @var \Drupal\Component\Datetime\TimeInterface
+     */
+    protected $time;
+
+    /**
+     * The Request Stack.
+     *
+     * @var Symfony\Component\HttpFoundation\RequestStack;
+     */
+    protected $requestStack;
+
+    /**
+     * Constructs an AutologoutSubscriber object.
+     *
+     * @param $autologout   The autologout manager service.
+     * @param $account      The user account service.
+     * @param $config       The Config service.
+     * @param $theme        The theme manager service.
+     * @param $time         The time service.
+     * @param $requestStack The Request Stack.
+     */
+    public function __construct(AutologoutManagerInterface $autologout, 
+        AccountInterface $account, ConfigFactory $config, 
+        ThemeManager $theme, TimeInterface $time, 
+        RequestStack $requestStack
+    ) {
+        $this->autoLogoutManager = $autologout;
+        $this->currentUser = $account;
+        $this->config = $config;
+        $this->theme = $theme;
+        $this->time = $time;
+        $this->requestStack = $requestStack;
     }
 
-    if ($this->autoLogoutManager->preventJs()) {
-      return;
+    /**
+     * Check for autologout JS.
+     *
+     * @param $event The request event.
+     *
+     * @return object
+     */
+    public function onRequest(GetResponseEvent $event)
+    {
+        $autologout_manager = $this->autoLogoutManager;
+
+        $uid = $this->currentUser->id();
+
+        if ($uid == 0) {
+            
+            $autologout_timeout = $this->requestStack->getCurrentRequest()
+                ->query->get('autologout_timeout');
+            $post = $this->requestStack->getCurrentRequest()->request->all();
+            if (!empty($autologout_timeout) && $autologout_timeout == 1 
+                && empty($post)
+            ) {
+                $autologout_manager->inactivityMessage();
+            }
+            return;
+        }
+
+        if ($this->autoLogoutManager->preventJs()) {
+            return;
+        }
+
+        $now = $this->time->getRequestTime();
+        // Check if anything wants to be refresh only. This URL would include the
+        // javascript but will keep the login alive whilst that page is opened.
+        $refresh_only = $autologout_manager->refreshOnly();
+        $timeout = $autologout_manager->getUserTimeout();
+        $timeout_padding = $this->config->get('autologout.settings')->get('padding');
+        $is_altlogout = strpos(
+            $event->getRequest()->getRequestUri(), 
+            '/autologout_alt_logout'
+        ) !== false;
+
+        // We need a backup plan if JS is disabled.
+        if (!$is_altlogout && !$refresh_only  
+            && isset($_SESSION['autologout_last'])
+        ) {
+            // If time since last access is > timeout + padding, log them out.
+            $diff = $now - $_SESSION['autologout_last'];
+            if ($diff >= ($timeout + (int) $timeout_padding)) {
+                $autologout_manager->logout();
+                /*User has changed so force Drupal to 
+                  remake decisions based on user.*/
+                global $theme, $theme_key;
+                drupal_static_reset();
+                $theme = null;
+                $theme_key = null;
+                $this->theme->getActiveTheme();
+                $autologout_manager->inactivityMessage();
+            } else {
+                $_SESSION['autologout_last'] = $now;
+            }
+        } else {
+            $_SESSION['autologout_last'] = $now;
+        }
     }
 
-    $now = $this->time->getRequestTime();
-    // Check if anything wants to be refresh only. This URL would include the
-    // javascript but will keep the login alive whilst that page is opened.
-    $refresh_only = $autologout_manager->refreshOnly();
-    $timeout = $autologout_manager->getUserTimeout();
-    $timeout_padding = $this->config->get('autologout.settings')->get('padding');
-    $is_altlogout = strpos($event->getRequest()->getRequestUri(), '/autologout_alt_logout') !== FALSE;
-
-    // We need a backup plan if JS is disabled.
-    if (!$is_altlogout && !$refresh_only && isset($_SESSION['autologout_last'])) {
-      // If time since last access is > timeout + padding, log them out.
-      $diff = $now - $_SESSION['autologout_last'];
-      if ($diff >= ($timeout + (int) $timeout_padding)) {
-        $autologout_manager->logout();
-        // User has changed so force Drupal to remake decisions based on user.
-        global $theme, $theme_key;
-        drupal_static_reset();
-        $theme = NULL;
-        $theme_key = NULL;
-        $this->theme->getActiveTheme();
-        $autologout_manager->inactivityMessage();
-      }
-      else {
-        $_SESSION['autologout_last'] = $now;
-      }
-    }
-    else {
-      $_SESSION['autologout_last'] = $now;
-    }
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public static function getSubscribedEvents() {
-    $events[KernelEvents::REQUEST][] = ['onRequest', 100];
+    /**
+     * {@inheritdoc}
+     * 
+     * @return string
+     */
+    public static function getSubscribedEvents()
+    {
+        $events[KernelEvents::REQUEST][] = ['onRequest', 100];
 
-    return $events;
-  }
+        return $events;
+    }
 
 }
diff --git a/modules/contrib/autologout/src/Form/AutologoutBlockForm.php b/modules/contrib/autologout/src/Form/AutologoutBlockForm.php
index 7015635..22ecc56 100644
--- a/modules/contrib/autologout/src/Form/AutologoutBlockForm.php
+++ b/modules/contrib/autologout/src/Form/AutologoutBlockForm.php
@@ -1,5 +1,21 @@
 <?php
 
+/**
+ * Provides autologout block form Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\autologout\Form;
 
 use Drupal\autologout\AutologoutManagerInterface;
@@ -8,70 +24,105 @@
 use Symfony\Component\DependencyInjection\ContainerInterface;
 
 /**
- * Provides a settings for autologout module.
+ * Provides autologout block form Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-class AutologoutBlockForm extends FormBase {
+class AutologoutBlockForm extends FormBase
+{
 
-  /**
-   * The autologout manager service.
-   *
-   * @var \Drupal\autologout\AutologoutManagerInterface
-   */
-  protected $autoLogoutManager;
+    /**
+     * The autologout manager service.
+     *
+     * @var \Drupal\autologout\AutologoutManagerInterface
+     */
+    protected $autoLogoutManager;
 
-  /**
-   * {@inheritdoc}
-   */
-  public function getFormId() {
-    return 'autologout_block_settings';
-  }
+    /**
+     * {@inheritdoc}
+     *
+     * @return object
+     */
+    public function getFormId()
+    {
+        return 'autologout_block_settings';
+    }
 
-  /**
-   * Constructs an AutologoutBlockForm object.
-   *
-   * @param \Drupal\autologout\AutologoutManagerInterface $autologout
-   *   The autologout manager service.
-   */
-  public function __construct(AutologoutManagerInterface $autologout) {
-    $this->autoLogoutManager = $autologout;
-  }
+    /**
+     * Constructs an AutologoutBlockForm object.
+     *
+     * @param $autologout The autologout manager service.
+     */
+    public function __construct(AutologoutManagerInterface $autologout)
+    {
+        $this->autoLogoutManager = $autologout;
+    }
 
-  /**
-   * {@inheritdoc}
-   */
-  public static function create(ContainerInterface $container) {
-    return new static(
-      $container->get('autologout.manager')
-    );
-  }
+    /**
+     * {@inheritdoc}
+     *
+     * @param $container The container variable.
+     *
+     * @return object 
+     */
+    public static function create(ContainerInterface $container)
+    {
+        return new static(
+            $container->get('autologout.manager')
+        );
+    }
 
-  /**
-   * {@inheritdoc}
-   */
-  public function buildForm(array $form, FormStateInterface $form_state) {
-    $form['reset'] = [
-      '#type' => 'button',
-      '#value' => $this->t('Reset Timeout'),
-      '#weight' => 1,
-      '#limit_validation_errors' => FALSE,
-      '#executes_submit_callback' => FALSE,
-      '#ajax' => [
+    /**
+     * Defines form and form state interface and build form.
+     *
+     * Build the form using $form varibale using.
+     *
+     * @param $form       Build the form using $form varibale using.
+     * @param $form_state Build the form using $form_state interface.
+     *
+     * @return $form
+     */
+    public function buildForm(array $form, FormStateInterface $form_state)
+    {
+        $form['reset'] = [
+        '#type' => 'button',
+        '#value' => $this->t('Reset Timeout'),
+        '#weight' => 1,
+        '#limit_validation_errors' => false,
+        '#executes_submit_callback' => false,
+        '#ajax' => [
         'callback' => 'autologout_ajax_set_last',
-      ],
-    ];
+        ],
+        ];
 
-    $form['timer'] = [
-      '#markup' => $this->autoLogoutManager->createTimer(),
-    ];
+        $form['timer'] = [
+        '#markup' => $this->autoLogoutManager->createTimer(),
+        ];
 
-    return parent::buildForm($form, $form_state);
-  }
+        return parent::buildForm($form, $form_state);
+    }
 
-  /**
-   * {@inheritdoc}
-   */
-  public function submitForm(array &$form, FormStateInterface $form_state) {
-    // Submits on block form.
-  }
+    /**
+     * Build the form using $form varibale using.
+     *
+     * @param $form       Build the form using $form varibale using.
+     * @param $form_state Build the form using $form_state interface.
+     *
+     * @return object
+     */
+    public function submitForm(array &$form, FormStateInterface $form_state)
+    {
+        // Submits on block form.
+    }
 
 }
diff --git a/modules/contrib/autologout/src/Form/AutologoutSettingsForm.php b/modules/contrib/autologout/src/Form/AutologoutSettingsForm.php
index 5242212..74dbeac 100644
--- a/modules/contrib/autologout/src/Form/AutologoutSettingsForm.php
+++ b/modules/contrib/autologout/src/Form/AutologoutSettingsForm.php
@@ -1,5 +1,21 @@
 <?php
 
+/**
+ * Provides autologout settings form Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\autologout\Form;
 
 use Drupal\Core\Config\ConfigFactoryInterface;
@@ -11,441 +27,624 @@
 use Symfony\Component\DependencyInjection\ContainerInterface;
 
 /**
- * Provides settings for autologout module.
+ * Provides autologout settings form Implementation.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-class AutologoutSettingsForm extends ConfigFormBase {
-
-  /**
-   * The module manager service.
-   *
-   * @var \Drupal\Core\Extension\ModuleHandlerInterface
-   */
-  protected $moduleHandler;
-
-  /**
-   * The user.data service.
-   *
-   * @var \Drupal\user\UserDataInterface
-   */
-  protected $userData;
-
-  /**
-   * Constructs an AutologoutSettingsForm object.
-   *
-   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
-   *   The factory for configuration objects.
-   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
-   *   The module manager service.
-   * @param \Drupal\user\UserData $user_data
-   *   The user.data service.
-   */
-  public function __construct(ConfigFactoryInterface $config_factory, ModuleHandlerInterface $module_handler, UserData $user_data) {
-    parent::__construct($config_factory);
-    $this->moduleHandler = $module_handler;
-    $this->userData = $user_data;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public static function create(ContainerInterface $container) {
-    return new static(
-      $container->get('config.factory'),
-      $container->get('module_handler'),
-      $container->get('user.data')
-    );
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getEditableConfigNames() {
-    return ['autologout.settings'];
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getFormId() {
-    return 'autologout_settings';
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function buildForm(array $form, FormStateInterface $form_state) {
-    $config = $this->config('autologout.settings');
-    $default_dialog_title = $config->get('dialog_title');
-    if (!$default_dialog_title) {
-      $default_dialog_title = $this->config('system.site')->get('name') . ' Alert';
+class AutologoutSettingsForm extends ConfigFormBase
+{
+
+    /**
+     * The module manager service.
+     *
+     * @var \Drupal\Core\Extension\ModuleHandlerInterface
+     */
+    protected $moduleHandler;
+
+    /**
+     * The user.data service.
+     *
+     * @var \Drupal\user\UserDataInterface
+     */
+    protected $userData;
+
+    /**
+     * Constructs an AutologoutSettingsForm object.
+     *
+     * @param $config_factory The factory for configuration objects.
+     * @param $module_handler The module manager service.
+     * @param $user_data      The user.data service.
+     */
+    public function __construct(ConfigFactoryInterface $config_factory, 
+        ModuleHandlerInterface $module_handler, UserData $user_data
+    ) {
+        parent::__construct($config_factory);
+        $this->moduleHandler = $module_handler;
+        $this->userData = $user_data;
     }
-    $form['timeout'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('Timeout value in seconds'),
-      '#default_value' => $config->get('timeout'),
-      '#size' => 8,
-      '#weight' => -10,
-      '#description' => $this->t('The length of inactivity time, in seconds, before automated log out. Must be 60 seconds or greater. Will not be used if role timeout is activated.'),
-    ];
-
-    $form['max_timeout'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('Max timeout setting'),
-      '#default_value' => $config->get('max_timeout'),
-      '#size' => 10,
-      '#maxlength' => 12,
-      '#weight' => -8,
-      '#description' => $this->t('The maximum logout threshold time that can be set by users who have the permission to set user level timeouts.'),
-    ];
-
-    $form['padding'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('Timeout padding'),
-      '#default_value' => $config->get('padding'),
-      '#size' => 8,
-      '#weight' => -6,
-      '#description' => $this->t('How many seconds to give a user to respond to the logout dialog before ending their session.'),
-    ];
-
-    $form['no_individual_logout_threshold'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Disable user-specific logout thresholds'),
-      '#default_value' => $config->get('no_individual_logout_threshold'),
-      '#weight' => -5,
-      '#description' => $this->t("Enable this to only allow autologout thresholds to be set globally on this form and don't allow users to set their own logout threshold."),
-    ];
-
-    $form['role_logout'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Role Timeout'),
-      '#default_value' => $config->get('role_logout'),
-      '#weight' => -4,
-      '#description' => $this->t('Enable each role to have its own timeout threshold and redirect URL, a refresh may be required for changes to take effect. Any role not ticked will use the default timeout value and default redirect URL. Any role can have a timeout value of 0 which means that they will never be logged out. Roles without specified redirect URL will use the default redirect URL.'),
-    ];
-
-    $form['role_logout_max'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Use highest role timeout value'),
-      '#default_value' => $config->get('role_logout_max'),
-      '#description' => $this->t('Check this to use the highest timeout value instead of the lowest for users that have more than one role.'),
-      '#states' => [
+
+    /**
+     * {@inheritdoc}
+     *
+     * @param $container This is the container variable.
+     *
+     * @return object
+     */
+    public static function create(ContainerInterface $container)
+    {
+        return new static(
+            $container->get('config.factory'),
+            $container->get('module_handler'),
+            $container->get('user.data')
+        );
+    }
+
+    /**
+     * {@inheritdoc}
+     *
+     * @return object
+     */
+    public function getEditableConfigNames()
+    {
+        return ['autologout.settings'];
+    }
+
+    /**
+     * {@inheritdoc}
+     *
+     * @return object
+     */
+    public function getFormId()
+    {
+        return 'autologout_settings';
+    }
+
+    /**
+     * This is the build Form.
+     *
+     * @param $form       This is the form variable.
+     * @param $form_state This is the form_state variable.
+     *
+     * @return object
+     */
+    public function buildForm(array $form, FormStateInterface $form_state)
+    {
+        $config = $this->config('autologout.settings');
+        $default_dialog_title = $config->get('dialog_title');
+        if (!$default_dialog_title) {
+            $default_dialog_title = $this->config('system.site')
+                ->get('name') . ' Alert';
+        }
+        $form['timeout'] = [
+        '#type' => 'textfield',
+        '#title' => $this->t('Timeout value in seconds'),
+        '#default_value' => $config->get('timeout'),
+        '#size' => 8,
+        '#weight' => -10,
+        '#description' => $this->t(
+            'The length of inactivity time,
+        in seconds, before automated log out. Must be 60 seconds or greater. 
+        Will not be used if role timeout is activated.'
+        ),
+        ];
+
+        $form['max_timeout'] = [
+        '#type' => 'textfield',
+        '#title' => $this->t('Max timeout setting'),
+        '#default_value' => $config->get('max_timeout'),
+        '#size' => 10,
+        '#maxlength' => 12,
+        '#weight' => -8,
+        '#description' => $this->t(
+            'The maximum logout threshold
+        time that can be set by users who have the permission to 
+        set user level timeouts.'
+        ),
+        ];
+
+        $form['padding'] = [
+        '#type' => 'textfield',
+        '#title' => $this->t('Timeout padding'),
+        '#default_value' => $config->get('padding'),
+        '#size' => 8,
+        '#weight' => -6,
+        '#description' => $this->t(
+            'How many seconds to give a user 
+        to respond to the logout dialog before ending their session.'
+        ),
+        ];
+
+        $form['no_individual_logout_threshold'] = [
+        '#type' => 'checkbox',
+        '#title' => $this->t('Disable user-specific logout thresholds'),
+        '#default_value' => $config->get('no_individual_logout_threshold'),
+        '#weight' => -5,
+        '#description' => $this->t(
+            "Enable this to only allow autologout 
+        thresholds to be set globally on this form and don't allow users 
+        to set their own logout threshold."
+        ),
+        ];
+
+        $form['role_logout'] = [
+        '#type' => 'checkbox',
+        '#title' => $this->t('Role Timeout'),
+        '#default_value' => $config->get('role_logout'),
+        '#weight' => -4,
+        '#description' => $this->t(
+            'Enable each role to have its own 
+        timeout threshold and redirect URL, a refresh may be required 
+        for changes to take effect. Any role not ticked will use the 
+        default timeout value and default redirect URL. Any role can 
+        have a timeout value of 0 which means that they will never be 
+        logged out. Roles without specified redirect URL will use the 
+        default redirect URL.'
+        ),
+        ];
+
+        $form['role_logout_max'] = [
+        '#type' => 'checkbox',
+        '#title' => $this->t('Use highest role timeout value'),
+        '#default_value' => $config->get('role_logout_max'),
+        '#description' => $this->t(
+            'Check this to use the highest 
+        timeout value instead of the lowest for users that have more 
+        than one role.'
+        ),
+        '#states' => [
         'visible' => [
           // Only show this field when the 'role_logout' checkbox is enabled.
-          ':input[name="role_logout"]' => ['checked' => TRUE],
+          ':input[name="role_logout"]' => ['checked' => true],
+        ],
         ],
-      ],
-    ];
-
-    $form['redirect_url'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('Redirect URL at logout'),
-      '#default_value' => $config->get('redirect_url'),
-      '#size' => 40,
-      '#description' => $this->t('Send users to this internal page when they are logged out.'),
-    ];
-
-    $form['no_dialog'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Do not display the logout dialog'),
-      '#default_value' => $config->get('no_dialog'),
-      '#description' => $this->t('Enable this if you want users to logout right away and skip displaying the logout dialog.'),
-    ];
-
-    $form['use_alt_logout_method'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Use alternate logout method'),
-      '#default_value' => $config->get('use_alt_logout_method'),
-      '#description' => $this->t('Normally when auto logout is triggered, it is done via an AJAX service call. Sites that use an SSO provider, such as CAS, are likely to see this request fail with the error "Origin is not allowed by Access-Control-Allow-Origin". The alternate approach is to have the auto logout trigger a page redirect to initiate the logout process instead.'),
-    ];
-
-    $form['dialog_title'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('Dialog title'),
-      '#default_value' => $default_dialog_title,
-      '#size' => 40,
-      '#description' => $this->t('This text will be dialog box title.'),
-    ];
-
-    $form['message'] = [
-      '#type' => 'textarea',
-      '#title' => $this->t('Message to display in the logout dialog'),
-      '#default_value' => $config->get('message'),
-      '#size' => 40,
-      '#description' => $this->t('This message must be plain text as it might appear in a JavaScript confirm dialog.'),
-    ];
-
-    $form['inactivity_message'] = [
-      '#type' => 'textarea',
-      '#title' => $this->t('Message to display to the user after they are logged out'),
-      '#default_value' => $config->get('inactivity_message'),
-      '#size' => 40,
-      '#description' => $this->t('This message is displayed after the user was logged out due to inactivity. You can leave this blank to show no message to the user.'),
-    ];
-
-    $form['inactivity_message_type'] = [
-      '#type' => 'select',
-      '#title' => $this->t('Type of the message to display'),
-      '#default_value' => $config->get('inactivity_message_type'),
-      '#description' => $this->t('Specifies whether to display the message as status or warning.'),
-      '#options' => [
+        ];
+
+        $form['redirect_url'] = [
+        '#type' => 'textfield',
+        '#title' => $this->t('Redirect URL at logout'),
+        '#default_value' => $config->get('redirect_url'),
+        '#size' => 40,
+        '#description' => $this->t(
+            'Send users to this internal page 
+        when they are logged out.'
+        ),
+        ];
+
+        $form['no_dialog'] = [
+        '#type' => 'checkbox',
+        '#title' => $this->t('Do not display the logout dialog'),
+        '#default_value' => $config->get('no_dialog'),
+        '#description' => $this->t(
+            'Enable this if you want users to 
+        logout right away and skip displaying the logout dialog.'
+        ),
+        ];
+
+        $form['use_alt_logout_method'] = [
+        '#type' => 'checkbox',
+        '#title' => $this->t('Use alternate logout method'),
+        '#default_value' => $config->get('use_alt_logout_method'),
+        '#description' => $this->t(
+            'Normally when auto logout is triggered, 
+        it is done via an AJAX service call. Sites that use an SSO provider, 
+        such as CAS, are likely to see this request fail with the error "Origin 
+        is not allowed by Access-Control-Allow-Origin". The alternate approach 
+        is to have the auto logout trigger a page redirect to initiate the logout 
+        process instead.'
+        ),
+        ];
+
+        $form['dialog_title'] = [
+        '#type' => 'textfield',
+        '#title' => $this->t('Dialog title'),
+        '#default_value' => $default_dialog_title,
+        '#size' => 40,
+        '#description' => $this->t('This text will be dialog box title.'),
+        ];
+
+        $form['message'] = [
+        '#type' => 'textarea',
+        '#title' => $this->t('Message to display in the logout dialog'),
+        '#default_value' => $config->get('message'),
+        '#size' => 40,
+        '#description' => $this->t(
+            'This message must be plain text as it might 
+        appear in a JavaScript confirm dialog.'
+        ),
+        ];
+
+        $form['inactivity_message'] = [
+        '#type' => 'textarea',
+        '#title' => $this->t(
+            'Message to display to the user after 
+        they are logged out'
+        ),
+        '#default_value' => $config->get('inactivity_message'),
+        '#size' => 40,
+        '#description' => $this->t(
+            'This message is displayed after the 
+        user was logged out due to inactivity. You can leave this blank 
+        to show no message to the user.'
+        ),
+        ];
+
+        $form['inactivity_message_type'] = [
+        '#type' => 'select',
+        '#title' => $this->t('Type of the message to display'),
+        '#default_value' => $config->get('inactivity_message_type'),
+        '#description' => $this->t(
+            'Specifies whether to display the 
+        message as status or warning.'
+        ),
+        '#options' => [
         MessengerInterface::TYPE_STATUS => $this->t('Status'),
         MessengerInterface::TYPE_WARNING => $this->t('Warning'),
-      ],
-    ];
-
-    $form['disable_buttons'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Disable buttons'),
-      '#default_value' => $config->get('disable_buttons'),
-      '#description' => $this->t('Disable Yes/No buttons for automatic logout popout.'),
-    ];
-
-    $form['yes_button'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('Custom confirm button text'),
-      '#default_value' => $config->get('yes_button'),
-      '#size' => 40,
-      '#description' => $this->t('Add custom text to confirmation button.'),
-    ];
-
-    $form['no_button'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('Custom decline button text'),
-      '#default_value' => $config->get('no_button'),
-      '#size' => 40,
-      '#description' => $this->t('Add custom text to decline button.'),
-    ];
-
-    $form['use_watchdog'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Enable watchdog Automated Logout logging'),
-      '#default_value' => $config->get('use_watchdog'),
-      '#description' => $this->t('Enable logging of automatically logged out users'),
-    ];
-
-    $form['enforce_admin'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Enforce auto logout on admin pages'),
-      '#default_value' => $config->get('enforce_admin'),
-      '#description' => $this->t('If checked, then users will be automatically logged out when administering the site.'),
-    ];
-    $form['whitelisted_ip_addresses'] = [
-      '#type' => 'textarea',
-      '#title' => $this->t('Whitelisted ip addresses'),
-      '#default_value' => $config->get('whitelisted_ip_addresses'),
-      '#size' => 40,
-      '#description' => $this->t('Users from these IP addresses will not be logged out.'),
-    ];
-    if ($this->moduleHandler->moduleExists('jstimer') && $this->moduleHandler->moduleExists('jst_timer')) {
-      $form['jstimer_format'] = [
+        ],
+        ];
+
+        $form['disable_buttons'] = [
+        '#type' => 'checkbox',
+        '#title' => $this->t('Disable buttons'),
+        '#default_value' => $config->get('disable_buttons'),
+        '#description' => $this->t(
+            'Disable Yes/No buttons for 
+        automatic logout popout.'
+        ),
+        ];
+
+        $form['yes_button'] = [
         '#type' => 'textfield',
-        '#title' => $this->t('Autologout block time format'),
-        '#default_value' => $config->get('jstimer_format'),
-        '#description' => $this->t('Change the display of the dynamic timer. Available replacement values are: %day%, %month%, %year%, %dow%, %moy%, %years%, %ydays%, %days%, %hours%, %mins%, and %secs%.'),
-      ];
-    }
+        '#title' => $this->t('Custom confirm button text'),
+        '#default_value' => $config->get('yes_button'),
+        '#size' => 40,
+        '#description' => $this->t(
+            'Add custom text to confirmation 
+        button.'
+        ),
+        ];
 
-    $form['role_container'] = [
-      '#type' => 'container',
-      '#weight' => -2,
-      '#states' => [
+        $form['no_button'] = [
+        '#type' => 'textfield',
+        '#title' => $this->t('Custom decline button text'),
+        '#default_value' => $config->get('no_button'),
+        '#size' => 40,
+        '#description' => $this->t('Add custom text to decline button.'),
+        ];
+
+        $form['use_watchdog'] = [
+        '#type' => 'checkbox',
+        '#title' => $this->t('Enable watchdog Automated Logout logging'),
+        '#default_value' => $config->get('use_watchdog'),
+        '#description' => $this->t(
+            'Enable logging of automatically 
+        logged out users'
+        ),
+        ];
+
+        $form['enforce_admin'] = [
+        '#type' => 'checkbox',
+        '#title' => $this->t('Enforce auto logout on admin pages'),
+        '#default_value' => $config->get('enforce_admin'),
+        '#description' => $this->t(
+            'If checked, then users will be 
+        automatically logged out when administering the site.'
+        ),
+        ];
+        $form['whitelisted_ip_addresses'] = [
+        '#type' => 'textarea',
+        '#title' => $this->t('Whitelisted ip addresses'),
+        '#default_value' => $config->get('whitelisted_ip_addresses'),
+        '#size' => 40,
+        '#description' => $this->t(
+            'Users from these IP addresses 
+        will not be logged out.'
+        ),
+        ];
+        if ($this->moduleHandler->moduleExists('jstimer')  
+            && $this->moduleHandler->moduleExists('jst_timer')
+        ) {
+            $form['jstimer_format'] = [
+            '#type' => 'textfield',
+            '#title' => $this->t('Autologout block time format'),
+            '#default_value' => $config->get('jstimer_format'),
+            '#description' => $this->t(
+                'Change the display of the dynamic timer. 
+            Available replacement values are: %day%, %month%, %year%, %dow%, %moy%, 
+            %years%, %ydays%, %days%, %hours%, %mins%, and %secs%.'
+            ),
+            ];
+        }
+
+        $form['role_container'] = [
+        '#type' => 'container',
+        '#weight' => -2,
+        '#states' => [
         'visible' => [
           // Only show this field when the 'role_logout' checkbox is enabled.
-          ':input[name="role_logout"]' => ['checked' => TRUE],
+          ':input[name="role_logout"]' => ['checked' => true],
+        ],
         ],
-      ],
-    ];
+        ];
 
-    $form['role_container']['table'] = [
-      '#type' => 'table',
-      '#header' => [
+        $form['role_container']['table'] = [
+        '#type' => 'table',
+        '#header' => [
         'enable' => $this->t('Customize'),
         'name' => $this->t('Role Name'),
         'timeout' => $this->t('Timeout (seconds)'),
         'url' => $this->t('Redirect URL at logout'),
-      ],
-    ];
-
-    foreach (user_roles(TRUE) as $key => $role) {
-      if ($key != 'authenticated') {
-        $form['role_container']['table'][$key] = [
-          'enabled' => [
-            '#type' => 'checkbox',
-            '#default_value' => $this->config('autologout.role.' . $key)->get('enabled'),
-          ],
-          'role' => [
-            '#type' => 'item',
-            '#value' => $key,
-            '#markup' => $key,
-          ],
-          'timeout' => [
-            '#type' => 'textfield',
-            '#default_value' => $this->config('autologout.role.' . $key)->get('timeout'),
-            '#size' => 8,
-          ],
-          'url' => [
-            '#type' => 'textfield',
-            '#default_value' => $this->config('autologout.role.' . $key)->get('url'),
-            '#size' => 40,
-          ],
+        ],
         ];
-      }
-    }
 
-    return parent::buildForm($form, $form_state);
-  }
-
-  /**
-   * Validate timeout range.
-   *
-   * Checks to see if timeout threshold is outside max/min values. Done here
-   * to centralize and stop repeated code. Hard coded min, configurable max.
-   *
-   * @param int $timeout
-   *   The timeout value in seconds to validate.
-   * @param int $max_timeout
-   *   (optional) Maximum value of timeout. If not set, system default is used.
-   *
-   * @return bool
-   *   Return TRUE or FALSE
-   */
-  public function timeoutValidate($timeout, $max_timeout = NULL) {
-    $validate = TRUE;
-    if (is_null($max_timeout)) {
-      $max_timeout = $this->config('autologout.settings')->get('max_timeout');
-    }
+        foreach (user_roles(true) as $key => $role) {
+            if ($key != 'authenticated') {
+                $form['role_container']['table'][$key] = [
+                'enabled' => [
+                '#type' => 'checkbox',
+                '#default_value' => $this->config('autologout.role.' . $key)
+                    ->get('enabled'),
+                ],
+                'role' => [
+                '#type' => 'item',
+                '#value' => $key,
+                '#markup' => $key,
+                ],
+                'timeout' => [
+                '#type' => 'textfield',
+                '#default_value' => $this->config('autologout.role.' . $key)
+                    ->get('timeout'),
+                '#size' => 8,
+                ],
+                'url' => [
+                '#type' => 'textfield',
+                '#default_value' => $this->config('autologout.role.' . $key)
+                    ->get('url'),
+                '#size' => 40,
+                ],
+                ];
+            }
+        }
 
-    if (!is_numeric($timeout) || $timeout < 0 || ($timeout > 0 && $timeout < 60) || $timeout > $max_timeout) {
-      // Less than 60, greater than max_timeout and is numeric.
-      // 0 is allowed now as this means no timeout.
-      $validate = FALSE;
+        return parent::buildForm($form, $form_state);
     }
-    return $validate;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function validateForm(array &$form, FormStateInterface $form_state) {
-    $values = $form_state->getValues();
-    $new_stack = [];
-    foreach ($values['table'] as $key => $pair) {
-      if (is_array($pair)) {
-        foreach ($pair as $pairkey => $pairvalue) {
-          $new_stack[$key][$pairkey] = $pairvalue;
+
+    /**
+     * Validate timeout range.
+     *
+     * Checks to see if timeout threshold is outside max/min values. Done here
+     * to centralize and stop repeated code. Hard coded min, configurable max.
+     *
+     * @param int $timeout     The timeout value in seconds to validate.
+     * @param int $max_timeout (optional) Maximum value of timeout. 
+     *                         If not set, system default is used.
+     *
+     * @return bool
+     *   Return TRUE or FALSE
+     */
+    public function timeoutValidate($timeout, $max_timeout = null)
+    {
+        $validate = true;
+        if (is_null($max_timeout)) {
+            $max_timeout = $this->config('autologout.settings')->get('max_timeout');
         }
-      }
-    }
 
-    $max_timeout = $values['max_timeout'];
+        if (!is_numeric($timeout) || $timeout < 0  
+            || ($timeout > 0 && $timeout < 60) || $timeout > $max_timeout
+        ) {
+            // Less than 60, greater than max_timeout and is numeric.
+            // 0 is allowed now as this means no timeout.
+            $validate = false;
+        }
+        return $validate;
+    }
 
-    if ($values['role_logout']) {
-      // Validate timeouts for each role.
-      foreach (array_keys(user_roles(TRUE)) as $role) {
-        if (empty($new_stack[$role]) || $new_stack[$role]['enabled'] == 0) {
-          // Don't validate role timeouts for non enabled roles.
-          continue;
+    /**
+     * Defines form and form state interface and validate form.
+     *
+     * Validate the form using $form varibale using.
+     *
+     * @param $form       Validate the form using $form varibale using.
+     * @param $form_state Validate the form using $form_state interface.
+     *
+     * @return object
+     */
+    public function validateForm(array &$form, FormStateInterface $form_state)
+    {
+        $values = $form_state->getValues();
+        $new_stack = [];
+        foreach ($values['table'] as $key => $pair) {
+            if (is_array($pair)) {
+                foreach ($pair as $pairkey => $pairvalue) {
+                    $new_stack[$key][$pairkey] = $pairvalue;
+                }
+            }
         }
 
-        $timeout = $new_stack[$role]['timeout'];
-        $validate = $this->timeoutValidate($timeout, $max_timeout);
-        if (!$validate) {
-          $form_state->setErrorByName('table][' . $role . '][timeout', $this->t('%role role timeout must be an integer greater than 60, less then %max or 0 to disable autologout for that role.', ['%role' => $role, '%max' => $max_timeout]));
+        $max_timeout = $values['max_timeout'];
+
+        if ($values['role_logout']) {
+            // Validate timeouts for each role.
+            foreach (array_keys(user_roles(true)) as $role) {
+                if (empty($new_stack[$role]) || $new_stack[$role]['enabled'] == 0) {
+                    // Don't validate role timeouts for non enabled roles.
+                    continue;
+                }
+
+                $timeout = $new_stack[$role]['timeout'];
+                $validate = $this->timeoutValidate($timeout, $max_timeout);
+                if (!$validate) {
+                    $form_state->setErrorByName(
+                        'table][' . $role . ']
+                    [timeout', $this->t(
+                            '%role role timeout must be an integer 
+                    greater than 60, less then %max or 0 to disable autologout 
+                    for that role.', ['%role' => $role, '%max' => $max_timeout]
+                        )
+                    );
+                }
+                $role_redirect_url = $new_stack[$role]['url'];
+                if (!empty($role_redirect_url)  
+                    && strpos($role_redirect_url, '/') !== 0
+                ) {
+                    $form_state->setErrorByName(
+                        'table][' . $role . ']
+                    [url', $this->t(
+                            "%role role redirect URL at logout :redirect_url
+                    must begin with a '/'", ['%role' => $role, ':redirect_url' => 
+                            $role_redirect_url]
+                        )
+                    );
+                }
+            }
         }
-        $role_redirect_url = $new_stack[$role]['url'];
-        if (!empty($role_redirect_url) && strpos($role_redirect_url, '/') !== 0) {
-          $form_state->setErrorByName('table][' . $role . '][url', $this->t("%role role redirect URL at logout :redirect_url must begin with a '/'", ['%role' => $role, ':redirect_url' => $role_redirect_url]));
+
+        $timeout = $values['timeout'];
+        // Validate timeout.
+        if ($timeout < 60) {
+            $form_state->setErrorByName(
+                'timeout', $this->t(
+                    'The timeout value 
+            must be an integer 60 seconds or greater.'
+                )
+            );
+        } elseif ($max_timeout <= 60) {
+            $form_state->setErrorByName(
+                'max_timeout', $this->t(
+                    'The max 
+            timeout must be an integer greater than 60.'
+                )
+            );
+        } elseif (!is_numeric($timeout) || ((int) $timeout != $timeout) 
+            || $timeout < 60 || $timeout > $max_timeout
+        ) {
+            $form_state->setErrorByName(
+                'timeout', $this->t(
+                    'The timeout must 
+            be an integer greater than or equal to 60 and less then 
+            or equal to %max.', ['%max' => $max_timeout]
+                )
+            );
         }
-      }
-    }
 
-    $timeout = $values['timeout'];
-    // Validate timeout.
-    if ($timeout < 60) {
-      $form_state->setErrorByName('timeout', $this->t('The timeout value must be an integer 60 seconds or greater.'));
-    }
-    elseif ($max_timeout <= 60) {
-      $form_state->setErrorByName('max_timeout', $this->t('The max timeout must be an integer greater than 60.'));
-    }
-    elseif (!is_numeric($timeout) || ((int) $timeout != $timeout) || $timeout < 60 || $timeout > $max_timeout) {
-      $form_state->setErrorByName('timeout', $this->t('The timeout must be an integer greater than or equal to 60 and less then or equal to %max.', ['%max' => $max_timeout]));
+        $redirect_url = $values['redirect_url'];
+
+        // Validate redirect url.
+        if (strpos($redirect_url, '/') !== 0) {
+            $form_state->setErrorByName(
+                'redirect_url', $this->t(
+                    "Redirect URL 
+            at logout :redirect_url must begin with a '/'", 
+                    [':redirect_url' => $redirect_url]
+                )
+            );
+        }
+        // Validate ip address list.
+        $whitelisted_ip_addresses_list = explode(
+            "\n", 
+            trim($values['whitelisted_ip_addresses'])
+        );
+
+        foreach ($whitelisted_ip_addresses_list as $ip_address) {
+            if (!empty($ip_address) && !filter_var(
+                trim($ip_address), 
+                FILTER_VALIDATE_IP
+            )
+            ) {
+                $form_state->setErrorByName(
+                    'whitelisted_ip_addresses',
+                    $this->t(
+                        'Whitlelisted IP address list should 
+                    contain only valid IP addresses, one per row'
+                    )
+                );
+            }
+        }
+        parent::validateForm($form, $form_state);
     }
 
-    $redirect_url = $values['redirect_url'];
-
-    // Validate redirect url.
-    if (strpos($redirect_url, '/') !== 0) {
-      $form_state->setErrorByName('redirect_url', $this->t("Redirect URL at logout :redirect_url must begin with a '/'", [':redirect_url' => $redirect_url]));
-    }
-    // Validate ip address list.
-    $whitelisted_ip_addresses_list = explode("\n", trim($values['whitelisted_ip_addresses']));
-
-    foreach ($whitelisted_ip_addresses_list as $ip_address) {
-      if (!empty($ip_address) && !filter_var(trim($ip_address), FILTER_VALIDATE_IP)) {
-        $form_state->setErrorByName(
-             'whitelisted_ip_addresses',
-                $this->t('Whitlelisted IP address list should contain only valid IP addresses, one per row')
-              );
-      }
-    }
-    parent::validateForm($form, $form_state);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function submitForm(array &$form, FormStateInterface $form_state) {
-    $values = $form_state->getValues();
-    $autologout_settings = $this->config('autologout.settings');
-
-    $old_no_individual_logout_threshold = $autologout_settings->get('no_individual_logout_threshold');
-    $new_no_individual_logout_threshold = (bool) $values['no_individual_logout_threshold'];
-
-    $autologout_settings->set('timeout', $values['timeout'])
-      ->set('max_timeout', $values['max_timeout'])
-      ->set('padding', $values['padding'])
-      ->set('no_individual_logout_threshold', $values['no_individual_logout_threshold'])
-      ->set('role_logout', $values['role_logout'])
-      ->set('role_logout_max', $values['role_logout_max'])
-      ->set('redirect_url', $values['redirect_url'])
-      ->set('no_dialog', $values['no_dialog'])
-      ->set('dialog_title', $values['dialog_title'])
-      ->set('message', $values['message'])
-      ->set('inactivity_message', $values['inactivity_message'])
-      ->set('inactivity_message_type', $values['inactivity_message_type'])
-      ->set('disable_buttons', $values['disable_buttons'])
-      ->set('yes_button', $values['yes_button'])
-      ->set('no_button', $values['no_button'])
-      ->set('enforce_admin', $values['enforce_admin'])
-      ->set('whitelisted_ip_addresses', $values['whitelisted_ip_addresses'])
-      ->set('use_alt_logout_method', $values['use_alt_logout_method'])
-      ->set('use_watchdog', $values['use_watchdog'])
-      ->save();
-
-    foreach ($values['table'] as $user) {
-      $this->configFactory()->getEditable('autologout.role.' . $user['role'])
-        ->set('enabled', $user['enabled'])
-        ->set('timeout', $user['timeout'])
-        ->set('url', $user['url'])
-        ->save();
-    }
+    /**
+     * Defines form and form state interface and submit form.
+     *
+     * Submit the form using $form varibale using.
+     *
+     * @param $form       Submit the form using $form varibale using.
+     * @param $form_state Sumbit the form using $form_state interface.
+     *
+     * @return object
+     */
+    public function submitForm(array &$form, FormStateInterface $form_state)
+    {
+        $values = $form_state->getValues();
+        $autologout_settings = $this->config('autologout.settings');
+
+        $old_no_individual_logout_threshold = $autologout_settings
+        ->get('no_individual_logout_threshold');
+        $new_no_individual_logout_threshold = (bool) 
+        $values['no_individual_logout_threshold'];
+
+        $autologout_settings->set('timeout', $values['timeout'])
+            ->set('max_timeout', $values['max_timeout'])
+            ->set('padding', $values['padding'])
+            ->set(
+                'no_individual_logout_threshold', 
+                $values['no_individual_logout_threshold']
+            )
+            ->set('role_logout', $values['role_logout'])
+            ->set('role_logout_max', $values['role_logout_max'])
+            ->set('redirect_url', $values['redirect_url'])
+            ->set('no_dialog', $values['no_dialog'])
+            ->set('dialog_title', $values['dialog_title'])
+            ->set('message', $values['message'])
+            ->set('inactivity_message', $values['inactivity_message'])
+            ->set('inactivity_message_type', $values['inactivity_message_type'])
+            ->set('disable_buttons', $values['disable_buttons'])
+            ->set('yes_button', $values['yes_button'])
+            ->set('no_button', $values['no_button'])
+            ->set('enforce_admin', $values['enforce_admin'])
+            ->set('whitelisted_ip_addresses', $values['whitelisted_ip_addresses'])
+            ->set('use_alt_logout_method', $values['use_alt_logout_method'])
+            ->set('use_watchdog', $values['use_watchdog'])
+            ->save();
+
+        foreach ($values['table'] as $user) {
+            $this->configFactory()->getEditable('autologout.role.' . $user['role'])
+                ->set('enabled', $user['enabled'])
+                ->set('timeout', $user['timeout'])
+                ->set('url', $user['url'])
+                ->save();
+        }
 
-    if (isset($values['jstimer_format'])) {
-      $autologout_settings->set('jstimer_format', $values['jstimer_format'])->save();
-    }
+        if (isset($values['jstimer_format'])) {
+            $autologout_settings->set(
+                'jstimer_format', 
+                $values['jstimer_format']
+            )->save();
+        }
 
-    // If individual logout threshold setting is no longer enabled,
-    // clear existing individual timeouts from users.
-    if ($old_no_individual_logout_threshold === FALSE && $new_no_individual_logout_threshold === TRUE) {
-      $users_timeout = $this->userData->get('autologout', NULL, 'timeout');
-      foreach ($users_timeout as $uid => $current_timeout_value) {
-        if ($current_timeout_value !== NULL) {
-          $this->userData->set('autologout', $uid, 'timeout', NULL);
+        // If individual logout threshold setting is no longer enabled,
+        // clear existing individual timeouts from users.
+        if ($old_no_individual_logout_threshold === false 
+            && $new_no_individual_logout_threshold === true
+        ) {
+            $users_timeout = $this->userData->get('autologout', null, 'timeout');
+            foreach ($users_timeout as $uid => $current_timeout_value) {
+                if ($current_timeout_value !== null) {
+                    $this->userData->set('autologout', $uid, 'timeout', null);
+                }
+            }
         }
-      }
-    }
 
-    parent::submitForm($form, $form_state);
-  }
+        parent::submitForm($form, $form_state);
+    }
 
 }
diff --git a/modules/contrib/autologout/tests/src/Functional/AutologoutAjaxTest.php b/modules/contrib/autologout/tests/src/Functional/AutologoutAjaxTest.php
index 2ebfc24..be6a475 100644
--- a/modules/contrib/autologout/tests/src/Functional/AutologoutAjaxTest.php
+++ b/modules/contrib/autologout/tests/src/Functional/AutologoutAjaxTest.php
@@ -1,5 +1,21 @@
 <?php
 
+/**
+ * Describe autologout ajax test file.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\Tests\autologout\Functional;
 
 use Drupal\Component\Serialization\Json;
@@ -11,14 +27,27 @@
  * @description Ensure the AJAX endpoints work as expected
  *
  * @group Autologout
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-class AutologoutAjaxTest extends BrowserTestBase {
-  /**
-   * Modules to enable.
-   *
-   * @var array
-   */
-  public static $modules = [
+class AutologoutAjaxTest extends BrowserTestBase
+{
+    /**
+     * Modules to enable.
+     *
+     * @var array
+     */
+    public static $modules = [
     'node',
     'system_test',
     'views',
@@ -26,148 +55,161 @@ class AutologoutAjaxTest extends BrowserTestBase {
     'autologout',
     'menu_ui',
     'block',
-  ];
-
-  /**
-   * User with admin rights.
-   *
-   * @var \Drupal\user\Entity\User
-   */
-  protected $privilegedUser;
-
-  /**
-   * Config factory.
-   *
-   * @var \Drupal\Core\Config\Config
-   */
-  protected $moduleConfig;
-
-  /**
-   * SetUp() performs any pre-requisite tasks that need to happen.
-   */
-  public function setUp() {
-    parent::setUp();
-    // Create and log in our privileged user.
-    $this->privilegedUser = $this->drupalCreateUser([
-      'access content',
-      'administer site configuration',
-      'access site reports',
-      'access administration pages',
-      'bypass node access',
-      'administer content types',
-      'administer nodes',
-      'administer autologout',
-      'change own logout threshold',
-    ]);
-    $this->drupalLogin($this->privilegedUser);
-
-    // Make node page default.
-    $this->config('system.site')->set('page.front', 'node')->save();
-
-    $this->moduleConfig = $this->container
-      ->get('config.factory')
-      ->getEditable('autologout.settings');
-  }
-
-  /**
-   * Test ajax logout callbacks work as expected.
-   */
-  public function testAutologoutByAjax() {
-    $this->moduleConfig->set('timeout', 100)->set('padding', 10)->save();
-
-    // Check that the user can access the page after login.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-
-    // Test the time remaining callback works as expected.
-    $result = Json::decode($this->drupalGet('autologout_ajax_get_time_left'));
-    self::assertEquals(
-      'insert',
-      $result[0]['command'],
-      'autologout_ajax_get_time_left returns an insert command for adding the jstimer onto the page'
-    );
-    self::assertEquals(
-      '#timer',
-      $result[0]['selector'],
-      'autologout_ajax_get_time_left specifies the #timer selector.'
-    );
-
-    $remainingTime = 0;
-    if (
-      !empty($result[1]['settings']['time']) &&
-      is_int($result[1]['settings']['time'])
-    ) {
-      $remainingTime = $result[1]['settings']['time'];
+    ];
+
+    /**
+     * User with admin rights.
+     *
+     * @var \Drupal\user\Entity\User
+     */
+    protected $privilegedUser;
+
+    /**
+     * Config factory.
+     *
+     * @var \Drupal\Core\Config\Config
+     */
+    protected $moduleConfig;
+
+    /**
+     * SetUp() performs any pre-requisite tasks that need to happen.
+     *
+     * @return object
+     */
+    public function setUp()
+    {
+        parent::setUp();
+        // Create and log in our privileged user.
+        $this->privilegedUser = $this->drupalCreateUser(
+            [
+            'access content',
+            'administer site configuration',
+            'access site reports',
+            'access administration pages',
+            'bypass node access',
+            'administer content types',
+            'administer nodes',
+            'administer autologout',
+            'change own logout threshold',
+            ]
+        );
+        $this->drupalLogin($this->privilegedUser);
+
+        // Make node page default.
+        $this->config('system.site')->set('page.front', 'node')->save();
+
+        $this->moduleConfig = $this->container
+            ->get('config.factory')
+            ->getEditable('autologout.settings');
     }
 
-    self::assertTrue(
-      $remainingTime > 0,
-      'autologout_ajax_get_time_left returns the remaining time as a positive integer'
-    );
-
-    // Test that ajax logout works as expected.
-    $this->drupalGet('autologout_ajax_logout');
-    $this->assertSession()->statusCodeEquals(200);
-
-    // Check we are now logged out.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    // Check further get time remaining requests return access denied.
-    $this->drupalGet('autologout_ajax_get_time_left');
-    $this->assertSession()->statusCodeEquals(403);
-
-    // Check further logout requests result in access denied.
-    $this->drupalGet('autologout_ajax_logout');
-    $this->assertSession()->statusCodeEquals(403);
-
-  }
-
-  /**
-   * Test ajax stay logged in callbacks work as expected.
-   */
-  public function testStayloggedInByAjax() {
-    $this->moduleConfig->set('timeout', 20)->set('padding', 5)->save();
-
-    // Check that the user can access the page after login.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    // Sleep for half the timeout.
-    sleep(14);
-
-    // Test that ajax stay logged in works.
-    $result = Json::decode($this->drupalGet('autologout_ajax_set_last'));
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertEquals(
-      'insert',
-      $result[0]['command'],
-      'autologout_ajax_set_last returns an insert command for adding the jstimer onto the page'
-    );
-    self::assertEquals(
-      '#timer',
-      $result[0]['selector'],
-      'autologout_ajax_set_last specifies the #timer selector.'
-    );
-
-    // Sleep for half the timeout again.
-    sleep(14);
-
-    // Check we are still logged in.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    // Logout.
-    $this->drupalGet('autologout_ajax_logout');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    // Check further requests to set last result in 403.
-    $this->drupalGet('autologout_ajax_set_last');
-    $this->assertSession()->statusCodeEquals(403);
-  }
+    /**
+     * Test ajax logout callbacks work as expected.
+     *
+     * @return object
+     */
+    public function testAutologoutByAjax()
+    {
+        $this->moduleConfig->set('timeout', 100)->set('padding', 10)->save();
+
+        // Check that the user can access the page after login.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+
+        // Test the time remaining callback works as expected.
+        $result = Json::decode($this->drupalGet('autologout_ajax_get_time_left'));
+        self::assertEquals(
+            'insert',
+            $result[0]['command'],
+            'autologout_ajax_get_time_left returns an insert 
+             command for adding the jstimer onto the page'
+        );
+        self::assertEquals(
+            '#timer',
+            $result[0]['selector'],
+            'autologout_ajax_get_time_left specifies the #timer selector.'
+        );
+
+        $remainingTime = 0;
+        if (!empty($result[1]['settings']['time']) 
+            && is_int($result[1]['settings']['time'])
+        ) {
+            $remainingTime = $result[1]['settings']['time'];
+        }
+
+        self::assertTrue(
+            $remainingTime > 0,
+            'autologout_ajax_get_time_left returns 
+            the remaining time as a positive integer'
+        );
+
+        // Test that ajax logout works as expected.
+        $this->drupalGet('autologout_ajax_logout');
+        $this->assertSession()->statusCodeEquals(200);
+
+        // Check we are now logged out.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        // Check further get time remaining requests return access denied.
+        $this->drupalGet('autologout_ajax_get_time_left');
+        $this->assertSession()->statusCodeEquals(403);
+
+        // Check further logout requests result in access denied.
+        $this->drupalGet('autologout_ajax_logout');
+        $this->assertSession()->statusCodeEquals(403);
+
+    }
+
+    /**
+     * Test ajax stay logged in callbacks work as expected.
+     *
+     * @return object
+     */
+    public function testStayloggedInByAjax()
+    {
+        $this->moduleConfig->set('timeout', 20)->set('padding', 5)->save();
+
+        // Check that the user can access the page after login.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        // Sleep for half the timeout.
+        sleep(14);
+
+        // Test that ajax stay logged in works.
+        $result = Json::decode($this->drupalGet('autologout_ajax_set_last'));
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertEquals(
+            'insert',
+            $result[0]['command'],
+            'autologout_ajax_set_last returns an insert 
+            command for adding the jstimer onto the page'
+        );
+        self::assertEquals(
+            '#timer',
+            $result[0]['selector'],
+            'autologout_ajax_set_last specifies the #timer selector.'
+        );
+
+        // Sleep for half the timeout again.
+        sleep(14);
+
+        // Check we are still logged in.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        // Logout.
+        $this->drupalGet('autologout_ajax_logout');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        // Check further requests to set last result in 403.
+        $this->drupalGet('autologout_ajax_set_last');
+        $this->assertSession()->statusCodeEquals(403);
+    }
 
 }
diff --git a/modules/contrib/autologout/tests/src/Functional/AutologoutSessionCleanupOnLoginTest.php b/modules/contrib/autologout/tests/src/Functional/AutologoutSessionCleanupOnLoginTest.php
index 98a88ec..4836d39 100644
--- a/modules/contrib/autologout/tests/src/Functional/AutologoutSessionCleanupOnLoginTest.php
+++ b/modules/contrib/autologout/tests/src/Functional/AutologoutSessionCleanupOnLoginTest.php
@@ -1,5 +1,21 @@
 <?php
 
+/**
+ * Describe autologout session cleanup file.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\Tests\autologout\Functional;
 
 use Behat\Mink\Driver\GoutteDriver;
@@ -13,217 +29,244 @@
  * @description Ensure that the autologout module cleans up stale sessions at login
  *
  * @group Autologout
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-class AutologoutSessionCleanupOnLoginTest extends BrowserTestBase {
-
-  /**
-   * Modules to enable.
-   *
-   * @var array
-   */
-  public static $modules = ['autologout', 'node'];
-
-  /**
-   * A store references to different sessions.
-   *
-   * @var array
-   */
-  protected $loggedInUsers = [];
-
-  /**
-   * User with admin rights.
-   *
-   * @var \Drupal\user\Entity\User|false
-   */
-  protected $privilegedUser;
-
-  /**
-   * Database service.
-   *
-   * @var \Drupal\Core\Database\Connection
-   */
-  protected $database;
-
-  /**
-   * Config factory service.
-   *
-   * @var \Drupal\Core\Config\ConfigFactoryInterface
-   */
-  protected $configFactory;
-
-  /**
-   * Performs any pre-requisite tasks that need to happen.
-   */
-  public function setUp() {
-    parent::setUp();
-    // Create and log in our privileged user.
-    $this->privilegedUser = $this->drupalCreateUser([
-      'access content overview',
-      'administer site configuration',
-      'access site reports',
-      'access administration pages',
-      'bypass node access',
-      'administer content types',
-      'administer nodes',
-      'administer autologout',
-      'change own logout threshold',
-    ]);
-    $this->configFactory = $this->container->get('config.factory');
-    $this->database = $this->container->get('database');
-  }
-
-  /**
-   * Tests that stale sessions are cleaned up at login.
-   */
-  public function testSessionCleanupAtLogin() {
-    $config = $this->container->get('config.factory')
-      ->getEditable('autologout.settings');
-    // For the purposes of the test, set the timeout periods to 5 seconds.
-    $config->set('timeout', 5)
-      ->set('padding', 0)
-      ->save();
-
-    // Login in session 1.
-    $this->drupalLogin($this->privilegedUser);
-    $this->mink->registerSession(
-      $this->privilegedUser->sessionId,
-      $this->getSession()
-    );
-
-    // Check one active session.
-    $sessions = $this->getSessions($this->privilegedUser);
-    self::assertEquals(
-      1,
-      count($sessions),
-      'After initial login there is one active session'
-    );
-
-    // Switch sessions.
-    $session1 = $this->stashSession();
-
-    // Login to session 2.
-    $this->drupalLogin($this->privilegedUser);
-
-    // Check two active sessions.
-    $sessions = $this->getSessions($this->privilegedUser);
-    self::assertEquals(
-      2,
-      count($sessions),
-      'After second login there is now two active session'
-    );
-
-    $this->stashSession();
-    // Switch sessions.
-    // Wait for sessions to expire.
-    sleep(6);
-
-    // Login to session 3.
-    $this->drupalLogin($this->privilegedUser);
-
-    // Check one active session.
-    $sessions = $this->getSessions($this->privilegedUser);
-    self::assertEquals(
-      1,
-      count($sessions),
-      'After third login, there is 1 active session, two stale sessions were cleaned up.'
-    );
-
-    // Switch back to session 1 and check no longer logged in.
-    $this->restoreSession($session1);
-    $this->drupalGet('node');
-    self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    $this->closeAllSessions();
-  }
-
-  /**
-   * Gets active sessions for given user.
-   *
-   * @param \Drupal\user\Entity\User $account
-   *   User account object.
-   *
-   * @return array
-   *   Array of sessions of the user.
-   */
-  public function getSessions(User $account) {
-    // Check there is one session in the sessions table.
-    $result = $this->database->select('sessions', 's')
-      ->fields('s')
-      ->condition('uid', $account->id())
-      ->orderBy('timestamp', 'DESC')
-      ->execute();
-    $sessions = [];
-    foreach ($result as $session) {
-      $sessions[] = $session;
+class AutologoutSessionCleanupOnLoginTest extends BrowserTestBase
+{
+
+    /**
+     * Modules to enable.
+     *
+     * @var array
+     */
+    public static $modules = ['autologout', 'node'];
+
+    /**
+     * A store references to different sessions.
+     *
+     * @var array
+     */
+    protected $loggedInUsers = [];
+
+    /**
+     * User with admin rights.
+     *
+     * @var \Drupal\user\Entity\User|false
+     */
+    protected $privilegedUser;
+
+    /**
+     * Database service.
+     *
+     * @var \Drupal\Core\Database\Connection
+     */
+    protected $database;
+
+    /**
+     * Config factory service.
+     *
+     * @var \Drupal\Core\Config\ConfigFactoryInterface
+     */
+    protected $configFactory;
+
+    /**
+     * Performs any pre-requisite tasks that need to happen.
+     *
+     * @return object
+     */
+    public function setUp()
+    {
+        parent::setUp();
+        // Create and log in our privileged user.
+        $this->privilegedUser = $this->drupalCreateUser(
+            [
+            'access content overview',
+            'administer site configuration',
+            'access site reports',
+            'access administration pages',
+            'bypass node access',
+            'administer content types',
+            'administer nodes',
+            'administer autologout',
+            'change own logout threshold',
+            ]
+        );
+        $this->configFactory = $this->container->get('config.factory');
+        $this->database = $this->container->get('database');
     }
 
-    return $sessions;
-  }
-
-  /**
-   * Initialises a new unique session.
-   *
-   * @return string
-   *   Unique identifier for the session just stored.
-   */
-  public function stashSession() {
-    if (empty($this->getSessionName())) {
-      return 0;
+    /**
+     * Tests that stale sessions are cleaned up at login.
+     *
+     * @return object
+     */
+    public function testSessionCleanupAtLogin()
+    {
+        $config = $this->container->get('config.factory')
+            ->getEditable('autologout.settings');
+        // For the purposes of the test, set the timeout periods to 5 seconds.
+        $config->set('timeout', 5)
+            ->set('padding', 0)
+            ->save();
+
+        // Login in session 1.
+        $this->drupalLogin($this->privilegedUser);
+        $this->mink->registerSession(
+            $this->privilegedUser->sessionId,
+            $this->getSession()
+        );
+
+        // Check one active session.
+        $sessions = $this->getSessions($this->privilegedUser);
+        self::assertEquals(
+            1,
+            count($sessions),
+            'After initial login there is one active session'
+        );
+
+        // Switch sessions.
+        $session1 = $this->stashSession();
+
+        // Login to session 2.
+        $this->drupalLogin($this->privilegedUser);
+
+        // Check two active sessions.
+        $sessions = $this->getSessions($this->privilegedUser);
+        self::assertEquals(
+            2,
+            count($sessions),
+            'After second login there is now two active session'
+        );
+
+        $this->stashSession();
+        // Switch sessions.
+        // Wait for sessions to expire.
+        sleep(6);
+
+        // Login to session 3.
+        $this->drupalLogin($this->privilegedUser);
+
+        // Check one active session.
+        $sessions = $this->getSessions($this->privilegedUser);
+        self::assertEquals(
+            1,
+            count($sessions),
+            'After third login, there is 1 active session, 
+            two stale sessions were cleaned up.'
+        );
+
+        // Switch back to session 1 and check no longer logged in.
+        $this->restoreSession($session1);
+        $this->drupalGet('node');
+        self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        $this->closeAllSessions();
     }
 
-    $session_id = $this->privilegedUser->sessionId;
-
-    do {
-      $this->generateSessionName($this->randomMachineName());
-    } while (isset($this->loggedInUsers[$this->getSessionName()]));
-
-    $this->loggedInUsers[$session_id] = clone $this->privilegedUser;
-    $this->mink->registerSession(
-      $this->getSessionName(),
-      new Session(new GoutteDriver())
-    );
-    $this->mink->setDefaultSessionName($this->getSessionName());
-    $this->loggedInUser = FALSE;
-
-    return $session_id;
-  }
-
-  /**
-   * Restores a previously stashed session.
-   *
-   * @param string $session_id
-   *   The session to restore as returned by stashSession();
-   *   This is also the path to the cookie file.
-   *
-   * @return string
-   *   The old session id that was replaced.
-   */
-  public function restoreSession($session_id) {
-    $old_session_id = NULL;
-
-    if (isset($this->loggedInUsers[$session_id])) {
-      $old_session_id = $this->stashSession();
+    /**
+     * Gets active sessions for given user.
+     *
+     * @param \Drupal\user\Entity\User $account User account object.
+     *
+     * @return array
+     *   Array of sessions of the user.
+     */
+    public function getSessions(User $account)
+    {
+        // Check there is one session in the sessions table.
+        $result = $this->database->select('sessions', 's')
+            ->fields('s')
+            ->condition('uid', $account->id())
+            ->orderBy('timestamp', 'DESC')
+            ->execute();
+        $sessions = [];
+        foreach ($result as $session) {
+            $sessions[] = $session;
+        }
+
+        return $sessions;
     }
 
-    $this->mink->setDefaultSessionName($session_id);
-
-    $this->loggedInUser = $this->loggedInUsers[$session_id];
-    $this->privilegedUser = $this->loggedInUsers[$session_id];
-    $this->loggedInUser->sessionId = $session_id;
-    $this->privilegedUser->sessionId = $session_id;
-
-    return $old_session_id;
-  }
-
-  /**
-   * Closes all stashed sessions and the current session.
-   */
-  public function closeAllSessions() {
-    $this->database->truncate('sessions')->execute();
-    $this->loggedInUsers = [];
-    $this->sessionName = NULL;
-    $this->loggedInUser = FALSE;
-    $this->mink->resetSessions();
-  }
+    /**
+     * Initialises a new unique session.
+     *
+     * @return string
+     *   Unique identifier for the session just stored.
+     */
+    public function stashSession()
+    {
+        if (empty($this->getSessionName())) {
+            return 0;
+        }
+
+        $session_id = $this->privilegedUser->sessionId;
+
+        do {
+            $this->generateSessionName($this->randomMachineName());
+        } while (isset($this->loggedInUsers[$this->getSessionName()]));
+
+        $this->loggedInUsers[$session_id] = clone $this->privilegedUser;
+        $this->mink->registerSession(
+            $this->getSessionName(),
+            new Session(new GoutteDriver())
+        );
+        $this->mink->setDefaultSessionName($this->getSessionName());
+        $this->loggedInUser = false;
+
+        return $session_id;
+    }
+
+    /**
+     * Restores a previously stashed session.
+     *
+     * @param string $session_id The session to restore as returned
+     *                           by stashSession();
+     *                           This is also the path to the cookie file.
+     *
+     * @return string
+     *   The old session id that was replaced.
+     */
+    public function restoreSession($session_id)
+    {
+        $old_session_id = null;
+
+        if (isset($this->loggedInUsers[$session_id])) {
+            $old_session_id = $this->stashSession();
+        }
+
+        $this->mink->setDefaultSessionName($session_id);
+
+        $this->loggedInUser = $this->loggedInUsers[$session_id];
+        $this->privilegedUser = $this->loggedInUsers[$session_id];
+        $this->loggedInUser->sessionId = $session_id;
+        $this->privilegedUser->sessionId = $session_id;
+
+        return $old_session_id;
+    }
+
+    /**
+     * Closes all stashed sessions and the current session.
+     *
+     * @return object
+     */
+    public function closeAllSessions()
+    {
+        $this->database->truncate('sessions')->execute();
+        $this->loggedInUsers = [];
+        $this->sessionName = null;
+        $this->loggedInUser = false;
+        $this->mink->resetSessions();
+    }
 
 }
diff --git a/modules/contrib/autologout/tests/src/Functional/AutologoutTest.php b/modules/contrib/autologout/tests/src/Functional/AutologoutTest.php
index 7d36f9a..45c72d5 100644
--- a/modules/contrib/autologout/tests/src/Functional/AutologoutTest.php
+++ b/modules/contrib/autologout/tests/src/Functional/AutologoutTest.php
@@ -1,8 +1,25 @@
 <?php
 
+/**
+ * Describe autologout test file.
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "GIT: <1001>"
+ *
+ * @link www.google.com
+ */
+
 namespace Drupal\Tests\autologout\Functional;
 
 use Drupal\Tests\BrowserTestBase;
+use Drupal\Core\StringTranslation\StringTranslationTrait;
 
 /**
  * Tests the autologout's features.
@@ -10,456 +27,522 @@
  * @description Ensures that the autologout module functions as expected
  *
  * @group Autologout
+ *
+ * @category Module
+ *
+ * @package Contrib
+ *
+ * @author Display Name <username@example.com>
+ *
+ * @license www.google.com ABC
+ *
+ * @version "Release: 8"
+ *
+ * @link www.google.com
  */
-class AutologoutTest extends BrowserTestBase {
-
-  /**
-   * Modules to enable.
-   *
-   * @var array
-   */
-  public static $modules = [
+class AutologoutTest extends BrowserTestBase
+{
+    use StringTranslationTrait;
+    /**
+     * Modules to enable.
+     *
+     * @var array
+     */
+    public static $modules = [
     'node',
     'system',
     'user',
     'views',
     'autologout',
     'block',
-  ];
-
-  /**
-   * User with admin rights.
-   *
-   * @var \Drupal\user\Entity\User
-   */
-  protected $privilegedUser;
-
-  /**
-   * The config factory service.
-   *
-   * @var \Drupal\Core\Config\ConfigFactoryInterface
-   */
-  protected $configFactory;
-
-  /**
-   * Stores the user data service used by the test.
-   *
-   * @var \Drupal\user\UserDataInterface
-   */
-  public $userData;
-
-  /**
-   * Performs any pre-requisite tasks that need to happen.
-   */
-  public function setUp() {
-    parent::setUp();
-    // Create and log in our privileged user.
-    $this->privilegedUser = $this->drupalCreateUser([
-      'access content',
-      'administer site configuration',
-      'access site reports',
-      'access administration pages',
-      'bypass node access',
-      'administer content types',
-      'administer nodes',
-      'administer autologout',
-      'change own logout threshold',
-      'access site reports',
-      'view the administration theme',
-    ]);
-
-    $this->configFactory = $this->container->get('config.factory');
-    $this->userData = $this->container->get('user.data');
-
-    // For the purposes of the test, set the timeout periods to 10 seconds.
-    $this->configFactory->getEditable('autologout.settings')
-      ->set('timeout', 10)
-      ->set('padding', 0)
-      ->save();
-    // Make node page default.
-    $this->configFactory->getEditable('system.site')
-      ->set('page.front', 'node')
-      ->save();
-
-    $this->drupalLogin($this->privilegedUser);
-  }
-
-  /**
-   * Tests the precedence of the timeouts.
-   *
-   * This tests the following function:
-   *  _autologout_get_user_timeout();
-   */
-  public function testAutologoutTimeoutPrecedence() {
-    $autologout_settings = $this->configFactory
-      ->getEditable('autologout.settings');
-    $autologout_role_settings = $this->configFactory
-      ->getEditable('autologout.role.authenticated');
-    $uid = $this->privilegedUser->id();
-    $autologout_user_settings = $this->container->get('user.data');
-
-    // Default used if no role is specified.
-    $autologout_settings->set('timeout', 100)
-      ->set('role_logout', FALSE)
-      ->save();
-    $autologout_role_settings->set('enabled', FALSE)
-      ->set('timeout', 200)
-      ->save();
-    $this->assertAutotimeout(
-      $uid,
-      100,
-      'User timeout uses default if no other option set'
-    );
-
-    // Default used if role selected but no user's role is selected.
-    $autologout_settings->set('role_logout', TRUE)->save();
-    $autologout_role_settings->set('enabled', FALSE)
-      ->set('timeout', 200)
-      ->save();
-    $this->assertAutotimeout(
-      $uid,
-      100,
-      'User timeout uses default if role timeouts are used but not one of the current user.'
-    );
-
-    // Role timeout is used if user's role is selected.
-    $autologout_settings->set('role_logout', TRUE)->save();
-    $autologout_role_settings->set('enabled', TRUE)
-      ->set('timeout', 200)
-      ->save();
-    $this->assertAutotimeout($uid, 200, 'User timeout uses role value');
-
-    // Role timeout is used if user's role is selected.
-    $autologout_settings->set('role_logout', TRUE)->save();
-    $autologout_role_settings->set('enabled', TRUE)
-      ->set('timeout', 0)
-      ->save();
-    $this->assertAutotimeout(
-      $uid,
-      0,
-      'User timeout uses role value of 0 if set for one of the user roles.'
-    );
-
-    // Role timeout used if personal timeout is empty string.
-    $autologout_settings->set('role_logout', TRUE)->save();
-    $autologout_role_settings->set('enabled', TRUE)
-      ->set('timeout', 200)
-      ->save();
-    $autologout_user_settings->set('autologout', $uid, 'timeout', '');
-    $autologout_user_settings->set('autologout', $uid, 'enabled', FALSE);
-    $this->assertAutotimeout(
-      $uid,
-      200,
-      'User timeout uses role value if personal value is the empty string.'
-    );
-
-    // Default timeout used if personal timeout is empty string.
-    $autologout_settings->set('role_logout', TRUE)->save();
-    $autologout_role_settings->set('enabled', FALSE)
-      ->set('timeout', 200)
-      ->save();
-    $autologout_user_settings->set('autologout', $uid, 'timeout', '');
-    $autologout_user_settings->set('autologout', $uid, 'enabled', FALSE);
-    $this->assertAutotimeout(
-      $uid,
-      100,
-      'User timeout uses default value if personal value is the empty string and no role timeout is specified.'
-    );
-
-    // Personal timeout used if set.
-    $autologout_settings->set('role_logout', TRUE)->save();
-    $autologout_role_settings->set('enabled', FALSE)
-      ->set('timeout', 200)
-      ->save();
-    $autologout_user_settings->set('autologout', $uid, 'timeout', 300);
-    $autologout_user_settings->set('autologout', $uid, 'enabled', TRUE);
-    $this->assertAutotimeout(
-      $uid,
-      300,
-      'User timeout uses default value if personal value is the empty string and no role timeout is specified.'
-    );
-  }
-
-  /**
-   * Tests a user is logged out after the default timeout period.
-   */
-  public function testAutologoutDefaultTimeout() {
-    // Check that the user can access the page after login.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    // Wait for timeout period to elapse.
-    sleep(15);
-
-    // Check we are now logged out.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
-  }
-
-  /**
-   * Tests a user is logged out with the alternate logout method.
-   */
-  public function testAutologoutAlternateLogoutMethod() {
-    // Test that alternate logout works as expected.
-    $this->drupalGet('autologout_alt_logout');
-    $this->assertSession()->statusCodeEquals(200);
-    $this->assertSession()->pageTextContains(
-      t('You have been logged out due to inactivity.')
-    );
-
-    // Check further logout requests result in access denied.
-    $this->drupalGet('autologout_alt_logout');
-    $this->assertSession()->statusCodeEquals(403);
-  }
-
-  /**
-   * Tests a user is not logged out within the default timeout period.
-   */
-  public function testAutologoutNoLogoutInsideTimeout() {
-    // Check that the user can access the page after login.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    // Wait within the timeout period.
-    sleep(5);
-
-    // Check we are still logged in.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
-  }
-
-  /**
-   * Tests the behaviour of the settings for submission.
-   */
-  public function testAutologoutSettingsForm() {
-    $edit = [];
-    $autologout_settings = $this->configFactory->getEditable('autologout.settings');
-    $autologout_settings->set('max_timeout', 1000)->save();
-
-    $roles = user_roles(TRUE);
-    // Unset authenticated, as it uses the default timeout value.
-    unset($roles['authenticated']);
-
-    // Test that it is possible to set a value above the max_timeout
-    // threshold.
-    $edit['timeout'] = 1500;
-    $edit['max_timeout'] = 2000;
-    $edit['padding'] = 60;
-    $edit['role_logout'] = TRUE;
-    foreach ($roles as $key => $role) {
-      $edit['table[' . $key . '][enabled]'] = TRUE;
-      $edit['table[' . $key . '][timeout]'] = 1200;
-      $edit['table[' . $key . '][url]'] = '/user/login';
+    ];
+
+    /**
+     * User with admin rights.
+     *
+     * @var \Drupal\user\Entity\User
+     */
+    protected $privilegedUser;
+
+    /**
+     * The config factory service.
+     *
+     * @var \Drupal\Core\Config\ConfigFactoryInterface
+     */
+    protected $configFactory;
+
+    /**
+     * Stores the user data service used by the test.
+     *
+     * @var \Drupal\user\UserDataInterface
+     */
+    public $userData;
+
+    /**
+     * Performs any pre-requisite tasks that need to happen.
+     * 
+     * @return object
+     */
+    public function setUp()
+    {
+        parent::setUp();
+        // Create and log in our privileged user.
+        $this->privilegedUser = $this->drupalCreateUser(
+            [
+            'access content',
+            'administer site configuration',
+            'access site reports',
+            'access administration pages',
+            'bypass node access',
+            'administer content types',
+            'administer nodes',
+            'administer autologout',
+            'change own logout threshold',
+            'access site reports',
+            'view the administration theme',
+            ]
+        );
+
+        $this->configFactory = $this->container->get('config.factory');
+        $this->userData = $this->container->get('user.data');
+
+        // For the purposes of the test, set the timeout periods to 10 seconds.
+        $this->configFactory->getEditable('autologout.settings')
+            ->set('timeout', 10)
+            ->set('padding', 0)
+            ->save();
+        // Make node page default.
+        $this->configFactory->getEditable('system.site')
+            ->set('page.front', 'node')
+            ->save();
+
+        $this->drupalLogin($this->privilegedUser);
     }
-    $edit['redirect_url'] = '/user/login';
-
-    $this->drupalPostForm(
-      'admin/config/people/autologout',
-      $edit,
-      t('Save configuration')
-    );
-    $this->assertSession()->pageTextContains(
-      t('The configuration options have been saved.')
-    );
-
-    // Test that out of range values are picked up.
-    $edit['timeout'] = 2500;
-    $edit['max_timeout'] = 2000;
-    $edit['padding'] = 60;
-    $edit['role_logout'] = TRUE;
-    foreach ($roles as $key => $role) {
-      $edit['table[' . $key . '][enabled]'] = TRUE;
-      $edit['table[' . $key . '][timeout]'] = 1200;
-      $edit['table[' . $key . '][url]'] = '/user/login';
+
+    /**
+     * Tests the precedence of the timeouts.
+     *
+     * This tests the following function:
+     *  _autologout_get_user_timeout();
+     *
+     * @return object
+     */
+    public function testAutologoutTimeoutPrecedence()
+    {
+        $autologout_settings = $this->configFactory
+            ->getEditable('autologout.settings');
+        $autologout_role_settings = $this->configFactory
+            ->getEditable('autologout.role.authenticated');
+        $uid = $this->privilegedUser->id();
+        $autologout_user_settings = $this->container->get('user.data');
+
+        // Default used if no role is specified.
+        $autologout_settings->set('timeout', 100)
+            ->set('role_logout', false)
+            ->save();
+        $autologout_role_settings->set('enabled', false)
+            ->set('timeout', 200)
+            ->save();
+        $this->assertAutotimeout(
+            $uid,
+            100,
+            'User timeout uses default if no other option set'
+        );
+
+        // Default used if role selected but no user's role is selected.
+        $autologout_settings->set('role_logout', true)->save();
+        $autologout_role_settings->set('enabled', false)
+            ->set('timeout', 200)
+            ->save();
+        $this->assertAutotimeout(
+            $uid,
+            100,
+            'User timeout uses default if role timeouts 
+            are used but not one of the current user.'
+        );
+
+        // Role timeout is used if user's role is selected.
+        $autologout_settings->set('role_logout', true)->save();
+        $autologout_role_settings->set('enabled', true)
+            ->set('timeout', 200)
+            ->save();
+        $this->assertAutotimeout($uid, 200, 'User timeout uses role value');
+
+        // Role timeout is used if user's role is selected.
+        $autologout_settings->set('role_logout', true)->save();
+        $autologout_role_settings->set('enabled', true)
+            ->set('timeout', 0)
+            ->save();
+        $this->assertAutotimeout(
+            $uid,
+            0,
+            'User timeout uses role value of 0 if set for one of the user roles.'
+        );
+
+        // Role timeout used if personal timeout is empty string.
+        $autologout_settings->set('role_logout', true)->save();
+        $autologout_role_settings->set('enabled', true)
+            ->set('timeout', 200)
+            ->save();
+        $autologout_user_settings->set('autologout', $uid, 'timeout', '');
+        $autologout_user_settings->set('autologout', $uid, 'enabled', false);
+        $this->assertAutotimeout(
+            $uid,
+            200,
+            'User timeout uses role value if personal value is the empty string.'
+        );
+
+        // Default timeout used if personal timeout is empty string.
+        $autologout_settings->set('role_logout', true)->save();
+        $autologout_role_settings->set('enabled', false)
+            ->set('timeout', 200)
+            ->save();
+        $autologout_user_settings->set('autologout', $uid, 'timeout', '');
+        $autologout_user_settings->set('autologout', $uid, 'enabled', false);
+        $this->assertAutotimeout(
+            $uid,
+            100,
+            'User timeout uses default value if personal value 
+            is the empty string and no role timeout is specified.'
+        );
+
+        // Personal timeout used if set.
+        $autologout_settings->set('role_logout', true)->save();
+        $autologout_role_settings->set('enabled', false)
+            ->set('timeout', 200)
+            ->save();
+        $autologout_user_settings->set('autologout', $uid, 'timeout', 300);
+        $autologout_user_settings->set('autologout', $uid, 'enabled', true);
+        $this->assertAutotimeout(
+            $uid,
+            300,
+            'User timeout uses default value if personal value 
+            is the empty string and no role timeout is specified.'
+        );
     }
-    $edit['redirect_url'] = '/user/login';
-    $this->drupalPostForm(
-      'admin/config/people/autologout',
-      $edit,
-      t('Save configuration')
-    );
-    $this->assertSession()->pageTextNotContains(
-      t('The configuration options have been saved.')
-    );
-
-    // Test that out of range values are picked up.
-    $edit['timeout'] = 1500;
-    $edit['max_timeout'] = 2000;
-    $edit['padding'] = 60;
-    $edit['role_logout'] = TRUE;
-    foreach ($roles as $key => $role) {
-      $edit['table[' . $key . '][enabled]'] = TRUE;
-      $edit['table[' . $key . '][timeout]'] = 2500;
-      $edit['table[' . $key . '][url]'] = '/user/login';
+
+    /**
+     * Tests a user is logged out after the default timeout period.
+     *
+     * @return object
+     */
+    public function testAutologoutDefaultTimeout()
+    {
+        // Check that the user can access the page after login.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        // Wait for timeout period to elapse.
+        sleep(15);
+
+        // Check we are now logged out.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
     }
-    $edit['redirect_url'] = '/user/login';
-    $this->drupalPostForm(
-      'admin/config/people/autologout',
-      $edit,
-      t('Save configuration')
-    );
-    $this->assertSession()->pageTextNotContains(
-      t('The configuration options have been saved.')
-    );
-
-    // Test that role timeouts are not validated for disabled roles.
-    $edit['timeout'] = 1500;
-    $edit['max_timeout'] = 2000;
-    $edit['padding'] = 60;
-    $edit['role_logout'] = TRUE;
-    foreach ($roles as $key => $role) {
-      $edit['table[' . $key . '][enabled]'] = FALSE;
-      $edit['table[' . $key . '][timeout]'] = 1200;
-      $edit['table[' . $key . '][url]'] = '/user/login';
+
+    /**
+     * Tests a user is logged out with the alternate logout method.
+     *
+     * @return object
+     */
+    public function testAutologoutAlternateLogoutMethod()
+    {
+        // Test that alternate logout works as expected.
+        $this->drupalGet('autologout_alt_logout');
+        $this->assertSession()->statusCodeEquals(200);
+        $this->assertSession()->pageTextContains(
+            $this->t('You have been logged out due to inactivity.')
+        );
+
+        // Check further logout requests result in access denied.
+        $this->drupalGet('autologout_alt_logout');
+        $this->assertSession()->statusCodeEquals(403);
+    }
+
+    /**
+     * Tests a user is not logged out within the default timeout period.
+     *
+     * @return object
+     */
+    public function testAutologoutNoLogoutInsideTimeout()
+    {
+        // Check that the user can access the page after login.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        // Wait within the timeout period.
+        sleep(5);
+
+        // Check we are still logged in.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
+    }
+
+    /**
+     * Tests the behaviour of the settings for submission.
+     *
+     * @return object
+     */
+    public function testAutologoutSettingsForm()
+    {
+        $edit = [];
+        $autologout_settings = $this->configFactory
+            ->getEditable('autologout.settings');
+        $autologout_settings->set('max_timeout', 1000)->save();
+
+        $roles = user_roles(true);
+        // Unset authenticated, as it uses the default timeout value.
+        unset($roles['authenticated']);
+
+        // Test that it is possible to set a value above the max_timeout
+        // threshold.
+        $edit['timeout'] = 1500;
+        $edit['max_timeout'] = 2000;
+        $edit['padding'] = 60;
+        $edit['role_logout'] = true;
+        foreach ($roles as $key => $role) {
+            $edit['table[' . $key . '][enabled]'] = true;
+            $edit['table[' . $key . '][timeout]'] = 1200;
+            $edit['table[' . $key . '][url]'] = '/user/login';
+        }
+        $edit['redirect_url'] = '/user/login';
+
+        $this->drupalPostForm(
+            'admin/config/people/autologout',
+            $edit,
+            $this->t('Save configuration')
+        );
+        $this->assertSession()->pageTextContains(
+            $this->t('The configuration options have been saved.')
+        );
+
+        // Test that out of range values are picked up.
+        $edit['timeout'] = 2500;
+        $edit['max_timeout'] = 2000;
+        $edit['padding'] = 60;
+        $edit['role_logout'] = true;
+        foreach ($roles as $key => $role) {
+            $edit['table[' . $key . '][enabled]'] = true;
+            $edit['table[' . $key . '][timeout]'] = 1200;
+            $edit['table[' . $key . '][url]'] = '/user/login';
+        }
+        $edit['redirect_url'] = '/user/login';
+        $this->drupalPostForm(
+            'admin/config/people/autologout',
+            $edit,
+            $this->t('Save configuration')
+        );
+        $this->assertSession()->pageTextNotContains(
+            $this->t('The configuration options have been saved.')
+        );
+
+        // Test that out of range values are picked up.
+        $edit['timeout'] = 1500;
+        $edit['max_timeout'] = 2000;
+        $edit['padding'] = 60;
+        $edit['role_logout'] = true;
+        foreach ($roles as $key => $role) {
+            $edit['table[' . $key . '][enabled]'] = true;
+            $edit['table[' . $key . '][timeout]'] = 2500;
+            $edit['table[' . $key . '][url]'] = '/user/login';
+        }
+        $edit['redirect_url'] = '/user/login';
+        $this->drupalPostForm(
+            'admin/config/people/autologout',
+            $edit,
+            $this->t('Save configuration')
+        );
+        $this->assertSession()->pageTextNotContains(
+            $this->t('The configuration options have been saved.')
+        );
+
+        // Test that role timeouts are not validated for disabled roles.
+        $edit['timeout'] = 1500;
+        $edit['max_timeout'] = 2000;
+        $edit['padding'] = 60;
+        $edit['role_logout'] = true;
+        foreach ($roles as $key => $role) {
+            $edit['table[' . $key . '][enabled]'] = false;
+            $edit['table[' . $key . '][timeout]'] = 1200;
+            $edit['table[' . $key . '][url]'] = '/user/login';
+        }
+        $edit['redirect_url'] = '/user/login';
+
+        $this->drupalPostForm(
+            'admin/config/people/autologout',
+            $edit,
+            $this->t('Save configuration')
+        );
+        $this->assertSession()->pageTextContains(
+            $this->t('The configuration options have been saved.')
+        );
+        $this->drupalPostForm(
+            'admin/config/people/autologout', 
+            $edit, $this->t('Save configuration')
+        );
+        $this->assertText(
+            $this->t('The configuration options have been saved.'), 
+            'Unable to save autologout due to out of range role timeout 
+        for a role which is not enabled..'
+        );
+
+        // Test clearing of users individual timeout when this becomes disabled.
+        $uid = $this->privilegedUser->id();
+        // Activate individual user timeout for user.
+        $this->userData->set('autologout', $uid, 'timeout', 1600);
+
+        // Turn off individual settings.
+        $edit['no_individual_logout_threshold'] = true;
+        $this->drupalPostForm(
+            'admin/config/people/autologout', 
+            $edit, $this->t('Save configuration')
+        );
+
+        // Expected is that default value is returned, not user-overriden value.
+        $this->assertAutotimeout(
+            $uid, 1500, 'User timeout 
+        is cleared when setting no_individual_logout_threshold 
+        is activated.'
+        );
+
+    }
+
+    /**
+     * Tests a user is logged out and denied access to admin pages.
+     *
+     * @return object
+     */
+    public function testAutologoutDefaultTimeoutAccessDeniedToAdmin()
+    {
+        $autologout_settings = $this->configFactory
+            ->getEditable('autologout.settings');
+        // Enforce auto logout of admin pages.
+        $autologout_settings->set('enforce_admin', false)->save();
+
+        // Check that the user can access the page after login.
+        $this->drupalGet('admin/reports/status');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        // Wait for timeout period to elapse.
+        sleep(15);
+
+        // Check we are now logged out.
+        $this->drupalGet('admin/reports/status');
+        $this->assertSession()->statusCodeEquals(403);
+        self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
+        $this->assertSession()->pageTextContains(
+            $this->t('You have been logged out due to inactivity.')
+        );
+    }
+
+    /**
+     * Tests integration with the remember me module.
+     *
+     * Users who checked remember_me on login should never be logged out.
+     *
+     * @return object
+     */
+    public function testNoAutologoutWithRememberMe()
+    {
+        // Set the remember_me module data bit to TRUE.
+        $this->userData->set(
+            'remember_me',
+            $this->privilegedUser->id(),
+            'remember_me',
+            true
+        );
+
+        // Check that the user can access the page after login.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
+
+        // Wait for timeout period to elapse.
+        sleep(15);
+
+        // Check we are still logged in.
+        $this->drupalGet('node');
+        $this->assertSession()->statusCodeEquals(200);
+        self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
+    }
+
+    /**
+     * Tests the behaviour of custom message displayed on autologout.
+     *
+     * @return object
+     */
+    public function testCustomMessage()
+    {
+        $autologout_settings = $this->configFactory
+            ->getEditable('autologout.settings');
+        $inactivity_message = 'Custom message for test';
+
+        // Update message string in configuration.
+        $autologout_settings->set('inactivity_message', $inactivity_message)
+            ->save();
+
+        // Set time out for 5 seconds.
+        $autologout_settings->set('timeout', 5)->save();
+
+        // Wait for 20 seconds for timeout.
+        sleep(20);
+
+        // Access the admin page and verify user is logged out and custom message
+        // is displayed.
+        $this->drupalGet('admin/reports/status');
+        self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
+        $this->assertSession()->pageTextContains($inactivity_message);
+    }
+
+    /**
+     * Tests the behaviour of application when Autologout is enabled for admin.
+     *
+     * @return object
+     */
+    public function testAutologoutAdminPages()
+    {
+        $autologout_settings = $this->configFactory
+            ->getEditable('autologout.settings');
+        // Enforce auto logout of admin pages.
+        $autologout_settings->set('enforce_admin', true)->save();
+        // Set time out as 5 seconds.
+        $autologout_settings->set('timeout', 5)->save();
+        // Verify admin should not be logged out.
+        $this->drupalGet('admin/reports/status');
+        $this->assertSession()->statusCodeEquals('200');
+
+        // Wait until timeout.
+        sleep(20);
+
+        // Verify admin should be logged out.
+        $this->drupalGet('admin/reports/status');
+        self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
+        $this->assertSession()->pageTextContains(
+            $this->t('You have been logged out due to inactivity.')
+        );
+    }
+
+    /**
+     * Asserts the timeout for a particular user.
+     *
+     * @param int    $uid              User uid to assert the timeout for.
+     * @param int    $expected_timeout The expected timeout.
+     * @param string $message          The test message.
+     *
+     * @return object
+     */
+    public function assertAutotimeout($uid, $expected_timeout, $message = '')
+    {
+        self::assertEquals(
+            $this->container->get('autologout.manager')->getUserTimeout($uid),
+            $expected_timeout,
+            $message
+        );
     }
-    $edit['redirect_url'] = '/user/login';
-
-    $this->drupalPostForm(
-      'admin/config/people/autologout',
-      $edit,
-      t('Save configuration')
-    );
-    $this->assertSession()->pageTextContains(
-      t('The configuration options have been saved.')
-    );
-    $this->drupalPostForm('admin/config/people/autologout', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), 'Unable to save autologout due to out of range role timeout for a role which is not enabled..');
-
-    // Test clearing of users individual timeout when this becomes disabled.
-    $uid = $this->privilegedUser->id();
-    // Activate individual user timeout for user.
-    $this->userData->set('autologout', $uid, 'timeout', 1600);
-
-    // Turn off individual settings.
-    $edit['no_individual_logout_threshold'] = TRUE;
-    $this->drupalPostForm('admin/config/people/autologout', $edit, t('Save configuration'));
-
-    // Expected is that default value is returned, not user-overriden value.
-    $this->assertAutotimeout($uid, 1500, 'User timeout is cleared when setting no_individual_logout_threshold is activated.');
-
-  }
-
-  /**
-   * Tests a user is logged out and denied access to admin pages.
-   */
-  public function testAutologoutDefaultTimeoutAccessDeniedToAdmin() {
-    $autologout_settings = $this->configFactory->getEditable('autologout.settings');
-    // Enforce auto logout of admin pages.
-    $autologout_settings->set('enforce_admin', FALSE)->save();
-
-    // Check that the user can access the page after login.
-    $this->drupalGet('admin/reports/status');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    // Wait for timeout period to elapse.
-    sleep(15);
-
-    // Check we are now logged out.
-    $this->drupalGet('admin/reports/status');
-    $this->assertSession()->statusCodeEquals(403);
-    self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
-    $this->assertSession()->pageTextContains(
-      t('You have been logged out due to inactivity.')
-    );
-  }
-
-  /**
-   * Tests integration with the remember me module.
-   *
-   * Users who checked remember_me on login should never be logged out.
-   */
-  public function testNoAutologoutWithRememberMe() {
-    // Set the remember_me module data bit to TRUE.
-    $this->userData->set(
-      'remember_me',
-      $this->privilegedUser->id(),
-      'remember_me',
-      TRUE
-    );
-
-    // Check that the user can access the page after login.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
-
-    // Wait for timeout period to elapse.
-    sleep(15);
-
-    // Check we are still logged in.
-    $this->drupalGet('node');
-    $this->assertSession()->statusCodeEquals(200);
-    self::assertTrue($this->drupalUserIsLoggedIn($this->privilegedUser));
-  }
-
-  /**
-   * Tests the behaviour of custom message displayed on autologout.
-   */
-  public function testCustomMessage() {
-    $autologout_settings = $this->configFactory->getEditable('autologout.settings');
-    $inactivity_message = 'Custom message for test';
-
-    // Update message string in configuration.
-    $autologout_settings->set('inactivity_message', $inactivity_message)
-      ->save();
-
-    // Set time out for 5 seconds.
-    $autologout_settings->set('timeout', 5)->save();
-
-    // Wait for 20 seconds for timeout.
-    sleep(20);
-
-    // Access the admin page and verify user is logged out and custom message
-    // is displayed.
-    $this->drupalGet('admin/reports/status');
-    self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
-    $this->assertSession()->pageTextContains($inactivity_message);
-  }
-
-  /**
-   * Tests the behaviour of application when Autologout is enabled for admin.
-   */
-  public function testAutologoutAdminPages() {
-    $autologout_settings = $this->configFactory->getEditable('autologout.settings');
-    // Enforce auto logout of admin pages.
-    $autologout_settings->set('enforce_admin', TRUE)->save();
-    // Set time out as 5 seconds.
-    $autologout_settings->set('timeout', 5)->save();
-    // Verify admin should not be logged out.
-    $this->drupalGet('admin/reports/status');
-    $this->assertSession()->statusCodeEquals('200');
-
-    // Wait until timeout.
-    sleep(20);
-
-    // Verify admin should be logged out.
-    $this->drupalGet('admin/reports/status');
-    self::assertFalse($this->drupalUserIsLoggedIn($this->privilegedUser));
-    $this->assertSession()->pageTextContains(
-      t('You have been logged out due to inactivity.')
-    );
-  }
-
-  /**
-   * Asserts the timeout for a particular user.
-   *
-   * @param int $uid
-   *   User uid to assert the timeout for.
-   * @param int $expected_timeout
-   *   The expected timeout.
-   * @param string $message
-   *   The test message.
-   */
-  public function assertAutotimeout($uid, $expected_timeout, $message = '') {
-    self::assertEquals(
-      $this->container->get('autologout.manager')->getUserTimeout($uid),
-      $expected_timeout,
-      $message
-    );
-  }
 
 }
